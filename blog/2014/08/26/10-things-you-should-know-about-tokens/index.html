
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>关于 Token，你应该知道的十件事 - Alvin Zhu</title>
	<meta name="author" content="Alvin Zhu">

	
	<meta name="description" content="关于 Token，你应该知道的十件事 原文是一篇很好的讲述 Token 在 Web 应用中使用的文章，而这是我和 Special 合作翻译的译文。 1. Token 应该被保存起来（放到 local / session stograge 或者 cookies） 在单页应用程序中， &hellip;">
	<meta name="keywords" content="token, cookie, session, local, storage, web">

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="/atom.xml" rel="alternate" title="Alvin Zhu" type="application/atom+xml">
	
	<link rel="canonical" href="http://gbammc.github.io/blog/2014/08/26/10-things-you-should-know-about-tokens/">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	<link href='http://fonts.googleapis.com/css?family=Open+Sans:400italic,400,700' rel='stylesheet' type='text/css'>
	
</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
			<header id="header" class="inner"><div class="profilepic">	
	<script src="/javascripts/md5.js"></script>
	<script type="text/javascript">
		document.write("<img src='http://www.gravatar.com/avatar/" + MD5("gbammc@gmail.com") + "?s=160' alt='Profile Picture' style='width: 160px;' />");
	</script>
</div>
<h1><a href="/">Alvin Zhu</a></h1>
<p class="subtitle">"人类渺小，<br>但不代表我要永世困于壁内。"</p>
<nav id="main-nav"><ul class="main">
	<li><a href="/">首页</a></li>
	<li><a href="/blog/archives">全部文章</a></li>
	<li><a href="/blog/categories">分类列表</a></li>
	<li><a href="/about">关于我</a></li>
	<li><a href="/friends">友情链接</a></li>
	<li><a href="https://itunes.apple.com/cn/app/id574437211">ifanr - 爱范儿客户端</a></li>
	<li><a href="https://itunes.apple.com/cn/app/id611036705">数读 - 用数字读懂世界</a></li>
  <li><a href="https://itunes.apple.com/us/app/id890729702">Q.fm - 最好的《一些事一些情》第三方应用</a></li>
	<li><a href="http://www.scau123.com/hnb/">iSCAU - 华农学子必备</a></li>
</ul></nav>
<nav id="sub-nav">
	<div class="social">
		
		<a class="weibo" href="http://www.weibo.com/blackteafeng" title="Weibo">Weibo</a>
		
		
		
		<a class="google" href="https://plus.google.com/101572322776670119375" rel="author" title="Google+">Google+</a>
		
		
		<a class="twitter" href="http://twitter.com/alvin_zhu" title="Twitter">Twitter</a>
		
		
		<a class="github" href="https://github.com/gbammc" title="GitHub">GitHub</a>
		
		
		
		
		
		
		
		<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
	</div>
</nav>

</header>				
			</div>
		</div>	
		<div class="mid-col">
			
				
			
			<div class="mid-col-container">
				<div id="content" class="inner"><article class="post" itemscope itemtype="http://schema.org/BlogPosting">
	<h1 class="title" itemprop="name">关于 Token，你应该知道的十件事</h1>
	<div class="entry-content" itemprop="articleBody"><p>原文是一篇很好的讲述 Token 在 Web 应用中使用的<a href="https://auth0.com/blog/2014/01/27/ten-things-you-should-know-about-tokens-and-cookies/#token-storage">文章</a>，而这是我和 <a href="http://www.specyci.com/">Special</a> 合作翻译的译文。</p>

<h1>1. Token 应该被保存起来（放到 local / session stograge 或者 cookies）</h1>

<p>  在单页应用程序中，有些用户刷新浏览器后会带来一些跟 token 相关的问题。而解决方法很简单：你应该把 token 保存到起来：<a href="https://github.com/auth0/angular-token-auth/blob/master/auth.client.js#L31">放到 session storage, local storage 或者是客户端的 cookie 里</a>。而浏览器不支持 session storage 时都应该转存到 cookies 里。</p>

<p>  如果你想“我把 token 保存到 cookie ，不就跟以前没有任何分别？”。可是在这种情况下你只是把 cookie 当作一个储存机制，而不是一种<a href="http://sitr.us/2011/08/26/cookies-are-bad-for-you.html">验证机制</a>。（比如说，这个 cookie 不会被 Web 框架用于用户验证，所以没有 XSRF 攻击的危险）。</p>

<!-- more -->


<h1>2. Tokens 除了像 cookie 一样有有效期，而且你可以有更多的操作方法</h1>

<p>  Tokens 应该有一个有效期（在 <a href="http://tools.ietf.org/html/draft-ietf-oauth-json-web-token-15#section-4.1.4">JSON Web Tokens</a> 中是作为 <code>exp</code> 属性），否则其他人只要登录过一次就可以永远地通过 API 的验证。Cookies 基于同样的理由也有一个有效期。</p>

<p>  在 Cookies 的使用中，有不同的选项可以控制 cookie 的生命周期：</p>

<pre><code>1. cookies 可以在浏览器关闭后删除（session cookies）；

2. 另外你可以实现服务器端的检查（通常由你使用的 Web 框架完成），还有也可以实现绝对有效期或弹性有效期（sliding window expiration）；

3. Cookies 可以带有有效期地保存起来（浏览器关闭后也不删除）。
</code></pre>

<p>  而在 tokens 的使用中，一旦 token 过期，只需要重新获取一个。你可以使用一个接口去刷新 token：</p>

<pre><code>1. 让旧的 token 失效；

2. 检查这个用户是不是还存在，权限是否被取消或者任何对你的程序来说是有必要的；

3. 得到一个更新了有效期的 token。
</code></pre>

<p>  你甚至可以把 token 原来的发布时间也保存起来，并且强制在两星期后重新登录什么的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">app</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="s1">&#39;/refresh_token&#39;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// verify the existing token</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">profile</span> <span class="o">=</span> <span class="nx">jwt</span><span class="p">.</span><span class="nx">verify</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">token</span><span class="p">,</span> <span class="nx">secret</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// if more than 14 days old, force login</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="nx">profile</span><span class="p">.</span><span class="nx">original_iat</span> <span class="o">-</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">14</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// iat == issued at</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">res</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="mi">401</span><span class="p">);</span> <span class="c1">// re-logging</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// check if the user still exists or if authorization hasn&#39;t been revoked</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">valid</span><span class="p">)</span> <span class="k">return</span> <span class="nx">res</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="mi">401</span><span class="p">);</span> <span class="c1">// re-logging</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// issue a new token</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">refreshed_token</span> <span class="o">=</span> <span class="nx">jwt</span><span class="p">.</span><span class="nx">sign</span><span class="p">(</span><span class="nx">profile</span><span class="p">,</span> <span class="nx">secret</span><span class="p">,</span> <span class="p">{</span> <span class="nx">expiresInMinutes</span><span class="o">:</span> <span class="mi">60</span><span class="o">*</span><span class="mi">5</span> <span class="p">});</span>
</span><span class='line'>  <span class="nx">res</span><span class="p">.</span><span class="nx">json</span><span class="p">({</span> <span class="nx">token</span><span class="o">:</span> <span class="nx">refreshed_token</span> <span class="p">});</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>  如果你需要撤回 tokens（当 token 的生存期比较长的时候这很有必要）那么你需要一个 token 的生成管理器去作检查。</p>

<h1>3. Local / session storage 不会跨域工作，请使用一个标记 cookie</h1>

<p>  如果你设置一个 cookie 的域名为 <code>.yourdomain.com</code> 它将可以被 <code>youdomain.com</code> 和 <code>app.yourdomain.com</code> 获取，这样用户登录并且转到 <code>app.yourdomain.com</code> 后也能很容易地从主域名找回这个 cookie（假如你的是电商网站）。</p>

<p>  而另一方面，保存在 local / session storage 的 tokens，就不能从不同的域名中读取（甚至是子域名也不行）。那你能怎么做？</p>

<p>  一个可能的选择是，当用户通过 <code>app.yourdomain.com</code> 上面的验证时你生成一个 token 并且作为一个 cookie 保存到 <code>.yourdomain.com</code></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">$</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="s1">&#39;/authenticate, function() {</span>
</span><span class='line'><span class="s1">  // store token on local/session storage or cookie</span>
</span><span class='line'><span class="s1">    ....</span>
</span><span class='line'>
</span><span class='line'><span class="s1">  // create a cookie signaling that user is logged in</span>
</span><span class='line'><span class="s1">  $.cookie(&#39;</span><span class="nx">loggedin</span><span class="s1">&#39;, profile.name, &#39;</span><span class="p">.</span><span class="nx">yourdomain</span><span class="p">.</span><span class="nx">com</span><span class="err">&#39;</span><span class="p">);</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>  然后，在 <code>youromdain.com</code> 中你可以检查这个 cookie 是不是已经存在了，并且如果存在的话就转到 <code>app.youromdain.com</code>去。从这以后，这个 token 将会对程序的子域名以及之后通常的流程都有效（直到这个 token 超过有效期）。</p>

<p>  不过这将会导致 cookie 存在但 token 被删除了或其他意外情况的发生。在这种情况下，用户将不得不重新登录。但重要的是，像我们之前说的，我们不会这个用 cookie 作为验证方法，只是作为一个存储机制去支持存储信息在不同的域名中。</p>

<h1>4. 每个 CORS（跨域资源共享）请求都会带上预请求（Preflight request）</h1>

<p>  有些人指出 Authorization header 不是一个<a href="http://www.w3.org/TR/cors/">simple header</a>，因此对于一个特定的 URLs 的所有请求都会带上一个预请求。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">OPTIONS</span> <span class="nx">https</span><span class="o">:</span><span class="c1">//api.foo.com/bar</span>
</span><span class='line'><span class="nx">GET</span> <span class="nx">https</span><span class="o">:</span><span class="c1">//api.foo.com/bar</span>
</span><span class='line'>   <span class="nx">Authorization</span><span class="o">:</span> <span class="nx">Bearer</span> <span class="p">....</span>
</span><span class='line'>
</span><span class='line'><span class="nx">OPTIONS</span> <span class="nx">https</span><span class="o">:</span><span class="c1">//api.foo.com/bar2</span>
</span><span class='line'><span class="nx">GET</span> <span class="nx">https</span><span class="o">:</span><span class="c1">//api.foo.com/bar2</span>
</span><span class='line'>   <span class="nx">Authorization</span><span class="o">:</span> <span class="nx">Bearer</span> <span class="p">....</span>
</span><span class='line'>
</span><span class='line'><span class="nx">GET</span> <span class="nx">https</span><span class="o">:</span><span class="c1">//api.foo.com/bar</span>
</span><span class='line'>   <span class="nx">Authorization</span><span class="o">:</span> <span class="nx">Bearer</span> <span class="p">....</span>
</span></code></pre></td></tr></table></div></figure>


<p>  但这只会发生在你发送 <code>Content-Type: application/json</code> 时。不过这说明已经出现在绝大多数的程序中了。</p>

<p>  一个小小的警告，the <code>OPTIONS</code> 请求不会带有 Authorization header 自身，所以你的网络框架应该支持区别对待 <code>OPTISON</code> 和后来的请求。（微软的 IIS 因为某些原因好像会有问题）。</p>

<h1>5. 当你需要流传送某些东西，请用 token 去获取一个已签名的请求。</h1>

<p>  当使用 cookies 时，你可以很容易开始一个文件的下载或流传送内容。然而，在 tokens 的使用中，请求是通过 XHR 完成的，你不能依赖于它。而解决方法应该是像 AWS 那样通过生成一个签名了的请求，例如，Hawk Bewits 是一个很好的框架去启用它：</p>

<p>  <strong>Request:</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">POST</span> <span class="o">/</span><span class="nx">download</span><span class="o">-</span><span class="nx">file</span><span class="o">/</span><span class="mi">123</span>
</span><span class='line'><span class="nx">Authorization</span><span class="o">:</span> <span class="nx">Bearer</span><span class="p">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>  <strong>Response:</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">ticket</span><span class="o">=</span><span class="nx">lahdoiasdhoiwdowijaksjdoaisdjoasidja</span>
</span></code></pre></td></tr></table></div></figure>


<p>  这个 ticket 是无状态并且是基于 URL 的：host + path + query + headers + timestamp + HMAC，并且有一个有效期。所以它可以用于像只能在5分钟内去下载一个文件。</p>

<p>  你然后可以转到 <code>/download-file/123? ticket=lahdoiasdhoiwdowijaksjdoaisdjoasidja</code> 中去。服务器就会检查这个 ticket 是不是有效然后像正常一样开始下一步的服务。</p>

<h1>6. <a href="http://baike.baidu.com/view/50325.htm">XSS</a> 比 <a href="http://baike.baidu.com/view/1609487.htm">XSRF</a> 要更容易防范</h1>

<p>  XSS 攻击的原理是，攻击者插入一段可执行的 JavaScripts 脚本，该脚本会读出用户浏览器的 cookies 并将它传输给攻击者，攻击者得到用户的 Cookies 后，即可冒充用户。</p>

<p>  但是要防范 XSS 也很简单，在写入 cookies 时，将 <code>HttpOnly</code> 设置为 <code>true</code>，客户端 JavaScripts 就无法读取该 cookies 的值，就可以有效防范 XSS 攻击。</p>

<p>  因为 Tokens 也是储存在本地的 session storage 或者是客户端的 cookies 中，也是会受到 XSS 攻击。所以在使用 tokens 的时候，必须要考虑过期机制，不然攻击者就可以永久持有受害用户帐号。</p>

<p>  相比 XSS，XSRF 的危害性更大，因为大多数 Web 框架都已经内置了 XSS 防范机制（例如在 Ruby on Rails 中，用户的输入在输出的时候都会做<code>转义</code>操作，攻击者插入的脚本就无法执行），</p>

<p>  对于大部分开发者而言，甚至连 XSRF 都不知道是什么玩意，更别提防范了。XSRF 目前并不是每个 Web 框架都有防范机制，因此开发者更应该留意 XSRF 。</p>

<h1>7. 注意 token 的大小</h1>

<p>  Token 机制在每次请求 API 的时候，都需要带上一个 <code>Authorization</code> 的 Http Header 。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="err">#</span> <span class="nx">Token</span>
</span><span class='line'><span class="nx">GET</span> <span class="o">/</span><span class="nx">foo</span>
</span><span class='line'><span class="nx">Authorization</span><span class="o">:</span> <span class="nx">Bearer</span> <span class="p">...</span><span class="mi">2</span><span class="nx">kb</span> <span class="nx">token</span><span class="p">...</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="err">#</span> <span class="nx">Cookie</span>
</span><span class='line'><span class="nx">GET</span> <span class="o">/</span><span class="nx">foo</span>
</span><span class='line'><span class="nx">connect</span><span class="p">.</span><span class="nx">sid</span><span class="o">:</span> <span class="p">...</span><span class="mi">20</span> <span class="nx">bytes</span> <span class="nx">cookie</span><span class="p">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>  Token 的大小其实由你储存在 token 中的信息量所决定，例如可能有 <code>nickname</code>，<code>openid</code> 等开发者另外加上的信息。</p>

<p>  但是 session cookies 机制只需要一个字串作为用户标识即可（例如 PHP 的 PHPSESSIONID），其中关于用户的信息都会直接储存到服务端的数据库中，当用户请求时才从数据库中捞出来用。</p>

<p>  当然 Token 机制也可以仿照 session cookies 机制这么做了，也是个有效控制 token 大小的方法。</p>

<p>  Token 中只保留关键的几条身份标识信息，其余都放到数据库里面了，权限控制的时候再捞出。这样做的好处是，开发者可以完全掌控 token，因为关键信息都已经是你代码和数据库中的一部分了，想怎么弄都可以了。</p>

<p>  举个例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">GET</span> <span class="o">/</span><span class="nx">foo</span>
</span><span class='line'><span class="nx">Authorization</span><span class="o">:</span> <span class="nx">Bearer</span> <span class="err">……</span><span class="mi">500</span> <span class="nx">bytes</span> <span class="nx">token</span><span class="err">…</span><span class="p">.</span>
</span><span class='line'><span class="nx">Then</span> <span class="nx">on</span> <span class="nx">the</span> <span class="nx">server</span><span class="o">:</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="s1">&#39;/api&#39;</span><span class="p">,</span>
</span><span class='line'>  <span class="c1">// 首先检查 token；</span>
</span><span class='line'>  <span class="nx">expressJwt</span><span class="p">({</span><span class="nx">secret</span><span class="o">:</span> <span class="nx">secret</span><span class="p">}),</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 然后再从数据库中捞出用户信息。</span>
</span><span class='line'>  <span class="kd">function</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">,</span> <span class="nx">next</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">req</span><span class="p">.</span><span class="nx">user</span><span class="p">.</span><span class="nx">extra_data</span> <span class="o">=</span> <span class="nx">get_from_db</span><span class="p">();</span>
</span><span class='line'>    <span class="nx">next</span><span class="p">();</span>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>  另外值得一提的是，你也可以把东西都丢 Cookies 里面（而不是只丢个身份标识字串）。只要确保资料经过了严格的加密，攻击者无法利用，现在有些 Web 框架已经有类似机制，例如 Nodejs 的这个插件 <a href="https://github.com/mozilla/node-client-sessions">mozilla/node-client-sessions</a>。</p>

<h1>8. 有需要的话，要加密并且签名 token</h1>

<p>  虽然 TLS/SSL 机制可以隔绝大多数中间人攻击，但是如果 token 中带有了用户的敏感信息，开发者也应该要加密这些信息。</p>

<p>  使用 JWT（文中第 9 点） 可以加密 token，但是由于目前大多数 Web 框架还未支持 JWT，所以可以使用 AES-CBC 算法加密 token。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">app</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="s1">&#39;/authenticate&#39;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// 校验用户；</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 加密 token；</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">encrypted</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">token</span><span class="o">:</span> <span class="nx">encryptAesSha256</span><span class="p">(</span><span class="s1">&#39;shhhh&#39;</span><span class="p">,</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">profile</span><span class="p">))</span> <span class="p">};</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 给加密后的 token 签名；</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">token</span> <span class="o">=</span> <span class="nx">jwt</span><span class="p">.</span><span class="nx">sign</span><span class="p">(</span><span class="nx">encrypted</span><span class="p">,</span> <span class="nx">secret</span><span class="p">,</span> <span class="p">{</span> <span class="nx">expiresInMinutes</span><span class="o">:</span> <span class="mi">60</span><span class="o">*</span><span class="mi">5</span> <span class="p">});</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">res</span><span class="p">.</span><span class="nx">json</span><span class="p">({</span> <span class="nx">token</span><span class="o">:</span> <span class="nx">token</span> <span class="p">});</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">function</span> <span class="nx">encryptAesSha256</span> <span class="p">(</span><span class="nx">password</span><span class="p">,</span> <span class="nx">textToEncrypt</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">cipher</span> <span class="o">=</span> <span class="nx">crypto</span><span class="p">.</span><span class="nx">createCipher</span><span class="p">(</span><span class="s1">&#39;aes-256-cbc&#39;</span><span class="p">,</span> <span class="nx">password</span><span class="p">);</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">crypted</span> <span class="o">=</span> <span class="nx">cipher</span><span class="p">.</span><span class="nx">update</span><span class="p">(</span><span class="nx">textToEncrypt</span><span class="p">,</span> <span class="s1">&#39;utf8&#39;</span><span class="p">,</span> <span class="s1">&#39;hex&#39;</span><span class="p">);</span>
</span><span class='line'>  <span class="nx">crypted</span> <span class="o">+=</span> <span class="nx">cipher</span><span class="p">.</span><span class="kr">final</span><span class="p">(</span><span class="s1">&#39;hex&#39;</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="nx">crypted</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 上面就是 encrypt-then-MAC （加密后签名）做法。 </span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>  当然你也可以用文中的第 7 点，直接将敏感信息丢数据库中。</p>

<h1>9. 将 JSON Web Tokens 应用到 OAuth 2</h1>

<p>  OAuth 2 是一个解决身份验证的授权协议，并且广泛地使用了 token 。</p>

<p>  用户通过 OAuth 2 协议授权第三方应用权限，然后服务器返回一个 <code>access_token</code> 给第三方应用，通常也带有 <code>scope</code> 参数，第三方应用通过带上 <code>access_token</code> 请求服务器，可以在授权范围（scope）内调用 API。</p>

<p>  一般来说，类似这种 token 是不透明的，就是核心数据都储存以 hash-table 结果储存在服务器中，客户端只持有一个<code>令牌</code>（access_token），任何人都可以用这个令牌在授权范围（scope）内调用服务器端的 API。</p>

<p>  Signed tokens（例如 <a href="http://jwt.io">JWT</a>)）和这种形式的 token 最主要的区别是，JWT 是无状态的，它不储存在服务端 hash-table 中，服务端中不保留 JWT 请求的相关信息，JWT 会把授权信息和 API 调用返回都丢一起返回给客户端。</p>

<p>  JWT 通常以 Base64 + AES 方式编码传输。OAuth 2 协议也支持 JWT，因为 OAuth 2 并未限制 access_token 数据格式，你可以将 JWT 应用在 OAuth 2 上。</p>

<h1>10. Tokens 不是万能的解决方法，得根据你的需求自行采用</h1>

<p>  这些年来，我们帮助过不少大公司实现了他们的以 Token 为基础的验证授权架构。曾经有一家 10k + 员工，有着大量数据的公司，他们想实现一个中央权限管理系统，其中有一个需要是某个员工只能读取某个国家某个医院某个床位的<code>id</code>和<code>name</code>字段数据，想想这样的细粒度的权限管理是多么难实现，无论是技术上还是行政上。</p>

<p>  当然采用 tokens 与否，得看大家的具体需求，但是，要忠告大家的是，不要什么内容都写到 tokens 了，加之前想想有没有这个必要。</p>
</div>

</article>

	<div class="share">
	<div class="addthis_toolbox addthis_default_style addthis_16x16_style">
	
	<a class="addthis_button_sinaweibo"></a>
	
	
	<a class="addthis_button_facebook"></a>
	
	
	
	
	<a class="addthis_button_compact"></a>
	<a class="addthis_counter addthis_bubble_style"></a>
	</div>
  <script type="text/javascript" src="http://s7.addthis.com/js/300/addthis_widget.js#pubid="></script>
</div>



<section id="comment">
    <h1 class="title">Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
</section>
</div>
			</div>
			<footer id="footer" class="inner"><p>
	Copyright &copy; 2014 - 
	
    	Alvin Zhu
	 - 
	Powered by <a href="http://octopress.org">Octopress</a>
</p>

Design credit: <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a></footer>
			<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->


<script type="text/javascript">
      var disqus_shortname = 'alvinzhusblog';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://gbammc.github.io/blog/2014/08/26/10-things-you-should-know-about-tokens/';
        var disqus_url = 'http://gbammc.github.io/blog/2014/08/26/10-things-you-should-know-about-tokens/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', 'UA-44493661-1']);
		_gaq.push(['_trackPageview']);

		(function() {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>



		</div>
	</div>
</body>
</html>
