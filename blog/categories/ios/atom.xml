<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | Alvin Zhu]]></title>
  <link href="http://gbammc.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://gbammc.github.io/"/>
  <updated>2014-08-26T12:13:05+08:00</updated>
  <id>http://gbammc.github.io/</id>
  <author>
    <name><![CDATA[Alvin Zhu]]></name>
    <email><![CDATA[gbammc@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[转]ARC深入浅出]]></title>
    <link href="http://gbammc.github.io/blog/2013/12/02/zhuan-arcshen-ru-qian-chu/"/>
    <updated>2013-12-02T00:37:00+08:00</updated>
    <id>http://gbammc.github.io/blog/2013/12/02/zhuan-arcshen-ru-qian-chu</id>
    <content type="html"><![CDATA[<p>ARC可谓iOS开发中一大利器，内存管理的大部份问题都能交由系统自动处理了，不过一些不太明显的小坑也需我们多加注意，不然用户在使用中出现闪退，那用户体验就差多了。最近看了@易飞扬 先生一系列关于ARC的博文，觉得非常详细易懂，可惜需要翻墙才能看到，所以转载到这里，同时对原文内容进行了一些小修改，再次感谢易先生的分享 :P</p>

<!-- more -->


<h1>TL;DR</h1>

<p>内存管理依循下面的基本原则:</p>

<ul>
<li>自己生成的对象，那么即是其持有者</li>
<li>不是自己生成的对象，也可成为其持有者（一个对象可以被多个人持有）</li>
<li>如果不想持有对象的时候，必须释放其所有权</li>
<li>不能释放已不再持有所有权的对象</li>
</ul>


<p>ARC使用准则:</p>

<ul>
<li>不能使用 retain/release/retainCount/autorelease</li>
<li>不能使用 NSAllocateObject/NSDeallocateObject</li>
<li>不能使用 NSZone</li>
<li>不能明示调用dealloc</li>
<li>内存管理相关的函数必须遵循命名规则</li>
<li>使用@autoreleasepool代替NSAutoreleasePool</li>
<li>Objective-C 对象不能作为C语言结构体（struct/union）的成员</li>
<li>[id]与[void*]之间需要明示cast</li>
</ul>


<p>原文地址：</p>

<p><a href="http://www.yifeiyang.net/development-of-the-iphone-simply-1/">iPhone开发之深入浅出 (1) — ARC是什么</a> &mdash;&mdash;&mdash; <a href="#1">本文传送门</a></p>

<p><a href="http://www.yifeiyang.net/development-of-the-iphone-simply-2/">iPhone开发之深入浅出 (2) — ARC之@property使用</a> &mdash;&mdash;&mdash; <a href="#2">本文传送门</a></p>

<p><a href="http://www.yifeiyang.net/development-of-the-iphone-simply-3/">iPhone开发之深入浅出 (3) — ARC之前世今生</a> &mdash;&mdash;&mdash; <a href="#3">本文传送门</a></p>

<p><a href="http://www.yifeiyang.net/development-of-the-iphone-simply-4/">iPhone开发之深入浅出 (4) — ARC之循环参照</a> &mdash;&mdash;&mdash; <a href="#4">本文传送门</a></p>

<p><a href="http://www.yifeiyang.net/development-of-the-iphone-simply-5/">iPhone开发之深入浅出 (5) — ARC之Outlet与弱引用</a> &mdash;&mdash;&mdash; <a href="#5">本文传送门</a></p>

<p><a href="http://www.yifeiyang.net/development-of-the-iphone-simply-6/">iPhone开发之深入浅出 (6) — ARC之对象转型</a> &mdash;&mdash;&mdash; <a href="#6">本文传送门</a></p>

<p><a href="http://www.yifeiyang.net/development-of-the-iphone-simply-7/">iPhone开发之深入浅出 (7) — ARC总结</a> &mdash;&mdash;&mdash; <a href="#7">本文传送门</a></p>

<hr />

<h1><span id="1">ARC是什么</span></h1>

<p>ARC是iOS5推出的新功能，全称叫 ARC(Automatic Reference Counting)。简单地说，就是代码中自动加入了retain/release，原先需要手动添加的用来处理内存管理的引用计数的代码可以自动地由编译器完成了。</p>

<h3>使用ARC的好处</h3>

<ul>
<li>使用ARC后，Objective-C的代码变得简单多了，因为我们不需要担心烦人的内存管理，担心内存泄露了</li>
<li>代码的总量变少了，看上去清爽了不少，也节省了劳动力</li>
<li>代码高速化，由于使用编译器管理引用计数，减少了低效代码的可能性</li>
</ul>


<h3>不好的地方</h3>

<ul>
<li>记住一堆新的ARC规则 — 关键字及特性等需要一定的学习周期；</li>
<li>一些旧的代码，第三方代码使用的时候比较麻烦；修改代码需要工数，要么修改编译开关</li>
</ul>


<p>如果只想对某个.m文件不应用ARC，可以只针对该类文件加上 -fno-objc-arc 编译FLAGS。（另外如果工程并未打开ARC，而要对某个文件应用ARC，可以加上-fobjc-arc编译FLAGS）</p>

<h3>ARC基本规则</h3>

<ul>
<li>retain, release, autorelease, dealloc由编译器自动插入，不能在代码中调用</li>
<li>dealloc虽然可以被重载，但是不能调用[super dealloc]</li>
</ul>


<h3>Objective-C对象</h3>

<p>ObjectiveC中的对象，有强参照(Strong reference)和弱参照(Weak reference)之分，当需要保持其他对象的时候，需要retain以确保对象引用计数加1。对象的持有者(owner)只要存在，那么该对象的强参照就一直存在。</p>

<h5>对象处理的基本规则是</h5>

<ul>
<li>只要对象的持有者存在（对象被强参照），那么就可以使用该对象</li>
<li>对象失去了持有者后，即被释放</li>
</ul>


<h3>强参照 (Strong reference)</h3>

<p><img src="/images/arc/ARC_outline_strong.JPG"></p>

<p>(s1)</p>

<p>firstName作为”natsu”字符串对象的最初持有者，是该NSString类型对象的Strong reference。</p>

<p>(s2)</p>

<p>这里将firstName代入到aName中，即aName也成为了@”natsu”字符串对象的持有者，对于该对象，aName也是Strong reference。</p>

<p>(s3)</p>

<p>这里，改变firstName的内容。生成新的字符串对象”maki”。这时候firstName成为”maki”的持有者，而@”natsu”的持有者只有aName。每个字符串对象都有各自的持有者，所以它们都在内存中都存在。</p>

<p>(s4)</p>

<p>追加新的变量otherName, 它将成为@”maki”对象的另一个持有者。即NSString类型对象的Strong reference。</p>

<p>(s5)</p>

<p>将otherName代入到aName，这时，aName将成为@”maki”字符串对象的持有者。而对象@”natsu”已经没有持有者了，该对象将被释放。</p>

<h3>弱参照 (Weak reference)</h3>

<p><img src="/images/arc/ARC_outline_weak.png"></p>

<p>(w1)</p>

<p>与强参照方式同样，firstName作为字符串对象@”natsu”的持有者存在。即是该NSString类型对象的Strong reference。</p>

<p>(w2)</p>

<p>使用关键字__weak，声明弱参照weakName变量，将firstName代入。这时weakName虽然参照@”natsu”，但仍是Weak reference。即weakName虽然能看到@”natsu”，但不是其持有者。</p>

<p>(w3)</p>

<p>firstName指向了新的对象@”maki”，成为其持有者，而对象@”natsu”因为没有了持有者，即被释放。同时weakName变量将被自动代入nil。</p>

<h3>引用关键字</h3>

<p>ARC中关于对象的引用参照，主要有下面几个关键字。使用strong, weak, autoreleasing限定的变量会被隐式初始化为nil。</p>

<h6>__strong</h6>

<p>变量声明缺省都带有__strong关键字，如果变量什么关键字都不写，那么缺省就是强参照。</p>

<h6>__weak</h6>

<p>上面已经看到了，这是弱参照的关键字。该概念是新特性，从 iOS 5/ Mac OS X 10.7 开始导入。由于该类型不影响对象的生命周期，所以如果对象之前就没有持有者，那么会出现刚创建就被释放的问题，比如下面的代码。</p>

<p><code>objc
NSString __weak *string = [[NSString alloc] initWithFormat:@"First Name: %@", [self firstName]];
NSLog(@"string: %@", string); //此时 string为空
</code></p>

<p>如果编译设定OS版本 Deployment Target 设定为这比这低的版本，那么编译时将报错(The current deployment target does not support automated __weak references)，这个时候，我们可以使用下面的__unsafe_unretained。</p>

<p>弱参照还有一个特征，即当参数对象失去所有者之后，变量会被自动付上nil (Zeroing)。</p>

<h6>__unsafe_unretained</h6>

<p>该关键字与<strong>weak一样，也是弱参照，与</strong>weak的区别只是是否执行nil赋值(Zeroing)。但是这样，需要注意变量所指的对象已经被释放了，地址还还存在，但内存中对象已经没有了。如果还是访问该对象，将引起「BAD_ACCESS」错误。</p>

<h6>__autoreleasing</h6>

<p>该关键字使对像延迟释放。比如你想传一个未初始化的对像引用到一个方法当中，在此方法中实例化此对像，那么这种情况可以使用__autoreleasing。他被经常用于函数有值参数返回时的处理，比如下面的例子。</p>

<p>``` objc
&ndash; (void) generateErrorInVariable:(__autoreleasing NSError **)paramError {
   &hellip;.</p>

<pre><code>*paramError = [[NSError alloc] initWithDomain:@"MyApp" code:1 userInfo:errorDictionary];
</code></pre>

<p>}</p>

<p>&hellip;.
{</p>

<pre><code>NSError *error = nil;
[self generateErrorInVariable:&amp;error];
NSLog(@"Error = %@", error);
</code></pre>

<p>}
```</p>

<p>又如函数的返回值是在函数中申请的，那么希望释放是在调用端时，往往有下面的代码。</p>

<p>``` objc
&ndash;(NSString *)stringTest
{</p>

<pre><code>NSString *retStr = [NSString stringWithString:@"test"];

return [[retStr retain] autorelease];
</code></pre>

<p>}</p>

<p>// 使用ARC</p>

<p>&ndash;(NSString *)stringTest
{</p>

<pre><code>__autoreleasing NSString *retStr = [NSString alloc] initWithString:@"test"];

return retStr;
</code></pre>

<p>}
```</p>

<p>即当方法的参数是id*，且希望方法返回时对象被autoreleased，那么使用该关键字。</p>

<h3>概括</h3>

<p>基本的ARC使用规则</p>

<ul>
<li>代码中不能使用retain, release, retain, autorelease</li>
<li>不重载dealloc（如果是释放对象内存以外的处理，是可以重载该函数的，但是不能调用[super dealloc]）</li>
<li>不能使用NSAllocateObject, NSDeallocateObject</li>
<li>不能在C结构体中使用对象指针</li>
<li>id与void *间的如果cast时需要用特定的方法（__bridge关键字）</li>
<li>不能使用NSAutoReleasePool、而需要@autoreleasepool块</li>
<li>不能使用“new”开始的属性名称 （如果使用会有下面的编译错误”Property’s synthesized getter follows Cocoa naming convention for returning ‘owned’ objects”）</li>
</ul>


<hr />

<h1><span id="2">ARC之@property使用</span></h1>

<h3>所有者属性</h3>

<p>我们先来看看与所有权有关系的属性，关键字间的对应关系。</p>

<table border="1">
    <tr>
        <td>属性值</td><td>关键字</td><td>所有权</td>
    </tr>
    <tr>
        <td>strong</td><td> __strong</td><td>有</td>
    </tr>
    <tr>
        <td>weak</td><td>__weak</td><td>无</td>
    </tr>
    <tr>
        <td>unsafe_unretained</td><td>__unsafe_unretained</td><td>无</td>
    </tr>
    <tr>
        <td>copy</td><td>__strong</td><td>有</td>
    </tr>
    <tr>
        <td>assign</td><td>__unsafe_unretained</td><td>无</td>
    </tr>
    <tr>
        <td>retain</td><td> __strong</td><td>有</td>
    <tr>
</table>


<h6>strong</h6>

<p>该属性值对应 __strong 关键字，即该属性所声明的变量将成为对象的持有者。</p>

<h6>weak</h6>

<p>该属性对应 __weak 关键字，与 __weak 定义的变量一致，该属性所声明的变量将没有对象的所有权，并且当对象被释放之后，对象将被自动赋值nil。</p>

<p>并且，delegate 和 Outlet 应该用 weak 属性来声明。同时，如上一回介绍的 iOS 5 之前的版本是没有 __weak 关键字的，所以 weak 属性是不能使用的。这种情况我们使用 unsafe_unretained。</p>

<h6>unsafe_unretained</h6>

<p>等效于__unsafe_unretaind关键字声明的变量；像上面说明的，iOS 5之前的系统用该属性代替 weak 来使用。</p>

<h6>copy</h6>

<p>与 strong 的区别是声明变量是拷贝对象的持有者。</p>

<h6>assign</h6>

<p>一般Scalar Varible用该属性声明，比如,int, BOOL。</p>

<h6>retain</h6>

<p>该属性与 strong 一致；只是可读性更强一些。</p>

<h3>读写相关的属性 (readwrite, readonly)</h3>

<p>读写相关的属性有 readwrite 和 readonly 两种，如果使用ARC之后，那么需要注意一下 readonly 属性的使用。</p>

<p>比如下面的变量声明。</p>

<p><code>objc
@property (nonatomic, readonly) NSString *name;
</code></p>

<p>一般声明为 readonly 的变量按理说应该不需要持有所有权了，但是在ARC有效的情况下，将出现下面的错误信息 ：</p>

<p><code>objc
“ARC forbids synthesizing a property of an Objective-C object with unspecified ownership or storage attribute”
</code></p>

<p>如果定义了ARC有效，那么必须要有所有者属性的定义；所以我们的代码改成这样，就OK了</p>

<p><code>objc
@property (nonatomic, strong, readonly) NSString *name;
</code></p>

<p>不过有一点，Scalar Varible的变量缺省都有 assign 的属性定义，所以不需要给他们单独的明示声明了。</p>

<hr />

<h1><span id="3">ARC产生缘由</span></h1>

<h3>Objective-C 内存管理</h3>

<p>和许多面向对象语言一样，Objective-C 中内存管理的方式其实就是指 引用计数 （Reference Counting）的使用准则。如下图所示，对象生成的时候必定被某个持有者拿着，如果有多个持有者的话，其引用计数就会递增；相反失去一个持有者那么引用计数即会递减，直到失去所有的持有者，才真正地从内测中释放自己</p>

<p><img src="/images/arc/ARC1.png"></p>

<h3>基本原则</h3>

<p>内存管理的依循下面的基本原则</p>

<ul>
<li>自己生成的对象，那么既是其持有者</li>
<li>不是自己生成的对象，也可成为其持有者（一个对象可以被多个人持有）</li>
<li>如果不想持有对象的时候，必须释放其所有权</li>
<li>不能释放已不再持有所有权的对象</li>
</ul>


<p>结合 Objective-C 语言中的方法，我们来看看基本的内存管理。</p>

<table border="1">
<thead>
    <tr>
        <th>方法</th>
        <th>动作</th>
    </tr>
</thead>
<tbody>
    <tr>
        <td>alloc/new/copy/mutableCopy</td>
        <td>生成对象并拥有所有权</td>
    </tr>
    <tr>
        <td>retain</td>
        <td>拥有对象所有权</td>
    </tr>
    <tr>
        <td>release</td>
        <td>释放对象所有权</td>
    </tr>
    <tr>
        <td>dealloc</td>
        <td>释放对象资源</td>
    </tr>
</tbody>
</table>


<p>Objective-C 语言内部严格遵守上面表格中的定义；首先是 alloc/new/copy/mutableCopy 这几个函数，并且是alloc/new/copy/mutableCopy 开头的函数，比如：allpcMyObject/newTheObject/copyThis/mutableCopyTheObject 等都必须遵循这个原则。</p>

<p>反而言之，如果不是 alloc/new/copy/mutableCopy 开头的函数，而且要返回对象的话，那么调用端只是生成对象，而不是其持有者。</p>

<p>``` objc
&ndash;(id)allocObject {</p>

<pre><code>/*
    * 生成对象并拥有所有权
    */
id obj = [[NSObject alloc] init];

/*
    * 自己一直是持有对象状态
    */
return obj;
</code></pre>

<p>}
```</p>

<p>如上面的例子，alloc 生成的对象，其所有权会传递给函数的调用端；即满足了 alloc 开头函数的命名规则。</p>

<p>``` objc
&ndash;(id)object {</p>

<pre><code>id obj = [[NSObject alloc] init];

/*
    * 自己一直是持有对象状态
    */

[obj autorelease];

/*
    * 对象还存在，只是并不持有它的所有权
    */

return obj;
</code></pre>

<p>}
```</p>

<p>这里我们用到了 autorelease 函数。它的作用既是将对象放入 NSAutoreleasePool 中，由其来维护其生命周期。换句话说对象的持有者是 NSAutoreleasePool；上面的例子中，object 返回后，调用者将不持有其所有权。（除非再调用 retain。）</p>

<p>用 autorelease 的一个理由既是让程序员来控制对象的存活周期，而不像 C/C++ 等语言中，出栈后，栈中数据都被自动废弃，或者用 { } 框住的自动变量，当出了范围就看不到了。在 Objective-C 中，只有当 [pool drain] 被调用的时候，才清空 pool 中所有登录的对象实体，在这之前，你可以像往常一样正常使用对象。</p>

<p>当然可以想象得到的，如果一个程序只有一个 NSAutoreleasePool，并在 main 中声明，程序结束时才 [pool drain]/[pool release] 的话，那么所有 autorelease 的对象都将塞满这个 pool，会耗掉系统大部分内存。所以，使用 NSAutoreleasePool 的时候也尽量建议局部使用。</p>

<h3>MRC编程准则</h3>

<p>基于以上原则，在 ARC 诞生之前，我们往往用下面准则来写代码。</p>

<ul>
<li><h4>生成对象时，使用autorelease</h4></li>
</ul>


<p>一般情况下，我们这样生成对象并使用</p>

<p><code>objc    
MyController* controller = [[MyController alloc] init];
// ......
[controller release];
</code></p>

<p>如果在 [controller release] 之前函数return了怎么样，内存泄露了不是；为了防患于未然，一般像下面一样 生成对象时，使用autorelease。这样一来，该对象就被自动加入到最近的那个 pool 中。</p>

<p><code>objc
MyController* controller = [[[MyController alloc] init] autorelease];
</code></p>

<ul>
<li><h4>对象赋值时，先autorelease后再retain</h4></li>
</ul>


<p>对象赋值的时候，如果之前不将变量所持有的对象释放，那么很可能引起内存泄露。比如下面的代码</p>

<p>``` objc
{</p>

<pre><code>    _member = [[TempValue alloc] init];
</code></pre>

<p>}</p>

<ul>
<li>(void)setValue:(TempValue *)value {
<em>member = value;
// 这时，之前持有的对象因为没有 release 而引起内存泄露
// 当然，先 [</em>member release] 后再代入也是可以的，
// 但是当与「对象在函数中返回时」的问题一同考虑时，
// 如果没有 return [[object retain] autorelease] 的保证，这里即使 [_member release]也是百搭
// 详细的解释见下
}
```</li>
</ul>


<p>鉴于以上原因，我们将原先的对象先autorelease后再将新对象retain赋值。</p>

<p>``` objc
{
  _member = [[TempValue alloc] init];
  // 这里，即使使用【生成对象时，使用autorelease】的准则，也没有关系
  // 使用autorelease一次就将制定对象放入pool中，放几次[pool drain]的时候就释放几次
}</p>

<ul>
<li>(void)setValue:(TempValue *)value {
[<em>member autorelease];
</em>member = [value retain];
}
```</li>
</ul>


<p>该原则遵循 Failed Self 的原则，虽然从性能上看有所损耗但是保证了代码</p>

<ul>
<li><h4>对象在函数中返回时，使用return [[object retain] autorelease]</h4></li>
</ul>


<p>严格地说，是除 alloc/new/copy/mutableCopy 开头函数以外的函数中，有对象放回时，使用return [[object retain] autorelease]。</p>

<p><strong>我们结合下面的例子来说明，并总结出该问题的几种解决方案</strong></p>

<p>``` objc
@implementation FooClass</p>

<ul>
<li><p>(void)setObject:(MyObject *)object;
{
   // 这里故意没有使用 autorelease，以便说明问题
   [<em>object release];
   </em>object = [object retain];
}</p></li>
<li><p>(id)object;
{
   return _object;
}</p></li>
<li><p>(void)dealloc;
{
   [_object release];
   [super dealloc];
}</p></li>
</ul>


<p>@end</p>

<p>@implementation BarClass</p>

<ul>
<li><p>(void)doStuff;
{
  FooClass * foo = [[FooClass alloc] init];</p>

<p>  // 创建第一个对象，引用计数 = 1
  MyObject * firstObject = [[MyObject alloc] init];
  // setObject中由于 [object retain] ，引用计数 = 2
  [foo setObject:firstObject];
  // 释放一次，引用计数 = 1；这之后对象有正确的所有权属性
  [firstObject release];</p>

<p>  // 通过非 alloc/new/copy/mutableCopy 开头函数得到对象
  // anObject 指向第一个对象，但是并没有其所有权，对象引用计数 = 1
  MyObject * anObject = [foo object];
  [anObject testMethod];</p>

<p>  // 创建第二个对象
  MyObject * secondObject = [[MyObject alloc] init];
  // setObject中由于 [_object release]; 第一个对象引用计数 = 0，内存被释放
  [foo setObject:secondObject];
  [secondObject release];</p>

<p>  // 程序在这里崩溃了，因为 anObject 指向了一个空地址
  [anObject testMethod];
}</p></li>
</ul>


<p>@end
```</p>

<ul>
<li><h4>生成对象时，使用autorelease</h4></li>
</ul>


<p>``` objc
@implementation BarClass</p>

<ul>
<li><p>(void)doStuff;
{
  FooClass * foo = [[FooClass alloc] init];</p>

<p>  MyObject * firstObject = [[[MyObject alloc] init] autorelease];
  [foo setObject:firstObject];</p>

<p>  MyObject * anObject = [foo object];
  [anObject testMethod];</p>

<p>  MyObject * secondObject = [[[MyObject alloc] init] autorelease];
  [foo setObject:secondObject];</p>

<p>  [anObject testMethod];
}</p></li>
</ul>


<p>@end
```</p>

<p>对象生成时，即被放入最近的 pool 中，不需要人为特殊的维护，对象的生命周期将被延续，出 {} 范围之时即对象释放之际。</p>

<ul>
<li><h4>对象代入时，先autorelease后再retain</h4></li>
</ul>


<p>``` objc
&ndash; (void)setObject:(MyObject *)object;
 {</p>

<pre><code> [_object autorelease];
 _object = [object retain];
</code></pre>

<p> }</p>

<ul>
<li>(id)object;
{
   // 遵循非 alloc/new/copy/mutableCopy 开头的函数，不赐予所有权原则
   return _object;
}
```</li>
</ul>


<p>同样的，对象被放入最近的 pool 中，第二次 setObject 后对象引用计数仍为1， pool 清空时才执行最后一次对象release，从而保证了代码的正确性。</p>

<ul>
<li><h4>对象在函数中返回时，使用return [[object retain] autorelease];</h4></li>
</ul>


<p>``` objc
&ndash; (void)setObject:(MyObject *)object;
 {</p>

<pre><code> [_object release];
 _object = [object retain];
</code></pre>

<p> }</p>

<ul>
<li>(id)object;
{
   // 遵循非 alloc/new/copy/mutableCopy 开头的函数，不赐予所有权原则
   return [[_object retain] autorelease];
}
```</li>
</ul>


<p>好不容易回到了本小节要说明的方法；可以看到这是从另一个角度解决了该问题：[foo object] 的时候保证引用计数是2，并将对象放入pool中维护。</p>

<h3>ARC编程准则</h3>

<p>在ARC中，如果不是 alloc/new/copy/mutableCopy 开头的函数，编译器会将生成的对象自动放入 autoReleasePool 中。如果是 __strong 修饰的变量，编译器会自动给其加上所有权。等等，详细，我们根据不同的关键字来看看编译器为我们具体做了什么。并从中总结出 ARC 的使用规则。</p>

<ul>
<li><h4>__strong</h4></li>
</ul>


<p>先来看看用 __strong 修饰的变量，以及缺省隐藏的 __strong 情况。</p>

<p>``` objc
{</p>

<pre><code>/*
 * 生成对象并拥有所有权
 */
id __strong obj = [[NSObject alloc] init];

/*
 * 自己一直是持有对象状态
 */
</code></pre>

<p>}</p>

<pre><code>/*
 * 变量出生命周期时，失去全部所有者，对象内存空间被释放
 */
</code></pre>

<p>```</p>

<p>这种情况毫无悬念，缺省使用 alloc/new/copy/mutableCopy 开头的函数也是这样的结果。并且在这里，编译器帮我们自动的调用了对象的 release 函数，不需要手工维护。再看看下面的情况。</p>

<p>``` objc
{</p>

<pre><code>/*
 * 生成对象但是并没有其所有权
 */
id __strong obj = [NSMutableArray array];

/*
 * 由于变量声明是强引用，自己一直是持有对象状态
 * 编译器根据函数名，再将该对象放入 autoreleasepool 中
 */
</code></pre>

<p>}</p>

<pre><code>/*
 * 变量出生命周期时，失去全部所有者，对象内存空间被释放
 */     
</code></pre>

<p>```</p>

<p>由上，虽然不是用 alloc/new/copy/mutableCopy 开头的函数得到的对象，由于是强参照，我们仍然成为对象的持有者。而这，正是编译器帮我们做到的。</p>

<pre><code>具体做的是什么呢？其实就是【对象在函数中返回时，使用return [[object retain] autorelease]】所描述的；如果你反汇编一下ARC生成的代码，可以看到这时会自动调用名为 objc_retainAutoreleaseReturnValue 的函数，而其作用和 [[object retain] autorelease] 一致。编译器通过函数名分析，如果不是 alloc/new/copy/mutableCopy 开头的函数，自动加入了这段代码。    
</code></pre>

<p>另外，缺省 __strong 修饰的变量，对象代入的时候也正确地保证对象所有者规则；代入新对象时，自动释放旧对象的参照，代入nil的时候，表示释放当前对象的强参照。</p>

<ul>
<li><h4>__weak</h4></li>
</ul>


<p>虽然大部分场合，大部分问题使用 _<em>strong 来编码就足够了；但是为了解决循环参照的问题 _</em>weak 关键字修饰【弱参照】变量就发挥了左右。关于循环参照的问题，准备在以后的博文中介绍；今天，主要看看编译器在背后怎么处理 __weak 变量的。</p>

<p>__weak 声明的变量其实是被放入一个weak表中，该表和引用计数的表格类似，是一个Hash表，都是以对象的内存地址做key，同时，针对一个对象地址的key，可以同时对应多个变量的地址。</p>

<p><strong>当一个 __weak 所指对象被释放时，系统按下面步骤来处理</strong></p>

<ul>
<li>从weak表中，通过对象地址（key）找到entry</li>
<li>将entry中所有指向该对象的变量设为nil</li>
<li>从weak表中删除该entry</li>
<li>从对象引用计数表中删除对象entry(通过通过对象地址找到)</li>
</ul>


<p>另外，当使用 __weak 修饰的变量的时候，变量将放入 autoreleasepool 中，并且用几次放几次。比如下面的简单例子。</p>

<p>``` objc
{</p>

<pre><code>id __weak o = obj;
NSLog(@"1 %@", o);
NSLog(@"2 %@", o);
NSLog(@"3 %@", o);
NSLog(@"4 %@", o);
NSLog(@"5 %@", o);
</code></pre>

<p>}
```</p>

<p>这里我们用了5次，那么pool中就被登录了5次；从效率上考虑这样当然不是很好，可以通过代入 __strong 修饰的强参照变量来避开这个问题。</p>

<p>``` objc
{</p>

<pre><code>id __weak o = obj;
id temp = o;
NSLog(@"1 %@", temp);
NSLog(@"2 %@", temp);
NSLog(@"3 %@", temp);
NSLog(@"4 %@", temp);
NSLog(@"5 %@", temp);
</code></pre>

<p>}
```</p>

<p>另外，还有通过重载 allowsWeakReference/retainWeakReference 函数来限制 __weak 声明变量使用回数的方法，毕竟不在本次讨论范畴之内，就此省略。</p>

<p>话说回来，为什么使用弱参照变量的时候，要将其放入 autoreleasepool 中呢？想想弱参照的定义就应该明白了 —- 如果在访问弱参照对象时，该对象被释放了怎么办，程序不就崩溃了嘛；所以为了解决该问题，又再一次用到了 pool。</p>

<ul>
<li><h5>__autoreleasing</h5></li>
</ul>


<p>虽然上面还没有讲到该关键字，但是编译器在很多时候已经用到了 autoreleasepool。比如非 alloc/new/copy/mutableCopy 开头的函数返回一个对象的时候，又比如使用一个 __weak 声明的变量的时候。</p>

<p>实际上，写ARC代码的时候，明示 __autoreleasing 声明变量和明示 __strong 声明变量一样基本上没有，因为编译器已经为我们做了很多，很智能了（前提是我们要按ARC的规则写代码）。</p>

<p>还有一种编译器缺省使用 __autoreleasing 关键字声明变量的时候：对象指针类型。比如下面的对应关系。</p>

<p>``` objc
id <em>obj == id __autoreleasing </em>obj</p>

<pre><code>NSObject **obj == NSObject * __autoreleasing *obj
</code></pre>

<p>```</p>

<p>所以，下面两个函数的是等价的。</p>

<p>``` objc
&ndash;(BOOL)performOperationWithError:(NSError **)error;</p>

<p>&ndash;(BOOL)performOperationWithError:(NSError * __autoreleasing *)error;
```</p>

<p>像下面的函数调用，为什么是可行的呢？</p>

<p><code>objc
NSError __strong *error = nil;
BOOL result = [obj performOperationWithError:&amp;error];
</code></p>

<p>其实，编译器是这样解释这段代码的</p>

<p><code>objc
NSError __strong *error = nil;
NSError __autoreleasing *tmp = error;
BOOL result = [obj performOperationWithError:&amp;tmp];
error = tmp;
</code></p>

<p>那么我们这样声明函数不就可以了吗？</p>

<p><code>objc
-(BOOL)performOperationWithError:(NSError * __strong *)error;
</code></p>

<p>答案是肯定的，你可以这样做，编译是可以通过，但你违反了非 alloc/new/copy/mutableCopy 开头的函数，不返回对象持有权的原则。这里是没有问题了，但也许影响到其他地方NG。</p>

<h3>ARC 规则</h3>

<p><strong>结合上面的讲解，我想你也应该能够总结出来使用ARC时的规则</strong>
（这里只列出本讲中涉及的内容，其他的内容以后总结）</p>

<ul>
<li>代码中不能使用retain, release, retain, autorelease</li>
<li>不能使用NSAllocateObject, NSDeallocateObject</li>
<li>不能使用NSAutoReleasePool、而需要@autoreleasepool块</li>
<li>严守内存管理相关函数命名规则</li>
</ul>


<p>关于函数命名，伴随ARC的导入，还有一系列函数的定义也被严格定义了，那就是以 init 开头的函数。init 函数作为alloc生成对象的初期化函数，需要按原样直接传递对象给调用段，所以下面的声明是OK的。</p>

<p><code>objc
-(id)initWithObject:(id)obj;
</code></p>

<p>而下面的是NG的。</p>

<p><code>objc    
-(void)initWithObject;
</code></p>

<hr />

<h1><span id="4">ARC之循环引用</span></h1>

<h3>概念</h3>

<p>当我们使用强参照（Strong reference）时，往往需要留意 <strong>循环参照</strong> 的问题。循环参照指的是两个对象被互相强参照，以至于任一对象都不能释放。</p>

<p>一般情况下，当对象之间有“父子关系”时，强参照的情况发生的比较多。比如通讯薄对象AddrBook和每个通讯录Entry的关系如下。</p>

<p><img src="/images/arc/arc_reference_cycle_1.png"></p>

<p>这种情况下，由于Entry对象被AddrBook强参照，所以不能释放。另一方面，如果Entry被释放了，AddrBook对象的强参照也就没有了，其对象也应被释放。</p>

<h3>解决方式</h3>

<p>像上面的例子，当多个对象间有“父子关系”时，需要在一侧用“弱参照”来解决循环参照问题。一般情况下，“父亲”作为“孩子”的拥有者，对“孩子”是强参照，而“孩子”对父亲是弱参照。</p>

<p><img src="/images/arc/arc_reference_cycle_2.png"></p>

<p>如图所示，当强参照AddrBook对象的变量被释放的时候，AddrBook对象将被自动释放，同时将失去Entry成员对象的强参照。另外，当AddrBook对象被释放的时候，Entry对象中的AddrBook变量也将由Zeroing机制，自动带入nil。我们不需要担心释放对象的再访问问题。</p>

<p>下面，我们将看看有几种情况下，需要注意循环参照问题。</p>

<h3>Delegate模式</h3>

<p>iOS程序中经常用到delegate模式，比如ViewController中，用ModalView打开/关闭DetailViewController时，需要delegate的设定。</p>

<p><img src="/images/arc/arc_reference_cycle_3.png"></p>

<p>这里，ViewController对象中强参照detailViewController，如果DetailViewController的delegate不是弱参照ViewController话，将引起循环参照。</p>

<p>另外，当类中使用weak @property声明的delegate变量时，如果参照对象被释放，该变量将被自动设为nil，不需要程序代码设置。</p>

<h3>Blocks</h3>

<p>Blocks是iOS 4开始导入的，可以理解为python或者lisp中的Lambda，C++11也已导入了该概念；类似概念ruby/smalltalk/JSP语言中也有定义。具体讲解见以后的文章，本节我们主要看看在Block中的循环参照问题。</p>

<p>比如，block对象用copy的属性定义时候，</p>

<p>``` objc
typedef void(^MyBlock)(void);</p>

<p>@interface MyObject : NSObject
@property (nonatomic, copy) MyBlock block;
@property (nonatomic, strong) NSString *str;</p>

<ul>
<li>(void)performBlock;
@end</li>
</ul>


<p>@implementation MyObject
@synthesize block, str;</p>

<ul>
<li>(void)performBlock {
  if (self.block) {
      self.block();
  }
}
@end
```</li>
</ul>


<p>调用端如下：</p>

<p>``` objc
MyObject *object = [[MyObject alloc] init];
object.str = @&ldquo;hoge&rdquo;;</p>

<p>object.block = ^{</p>

<pre><code>NSLog(@"block: str=%@", object.str);
</code></pre>

<p>};
[object performBlock];
```</p>

<p>我们看到，Block的构文中参照了object，同样object也强参照block。</p>

<p><img src="/images/arc/arc_reference_cycle_4.png"></p>

<p>为了解决该问题，我们可以有下面两种选择。</p>

<h6>使用__block关键字修饰</h6>

<p>使用__block关键字，让对象有读写权限，如果Block内的处理完毕就释放object。</p>

<p>``` objc
__block MyObject *object = [[MyObject alloc] init];
object.str = @&ldquo;hoge&rdquo;;</p>

<p>object.block = ^{</p>

<pre><code>NSLog(@"block: str=%@", object.str);
object = nil;
</code></pre>

<p>};
[object performBlock];
```</p>

<p>该关键字的意思就是让block取消对object的强参照，以避免循环参照。但是，有一个问题就是，object的释放动作是在Block内部执行，如果Block没有被执行的话，循环参照一直存在。比如上面的代码，如果第8行 [object performBlock]; 没有执行的话，那么一直还是循环参照状态。</p>

<h6>使用__weak关键字修饰</h6>

<p>另一种方案就是让Block的参照变为弱参照。</p>

<p>``` objc
MyObject *object = [[MyObject alloc] init];
object.str = @&ldquo;hoge&rdquo;;</p>

<p>__weak MyObject *weakObject = object;
object.block = ^{</p>

<pre><code>NSLog(@"block: str=%@", weakObject.str);
</code></pre>

<p>};
[object performBlock];
```</p>

<p>考虑到异步通信时Blocks的使用情况，weak变量weakObject有可能随时变为nil，所以类似于下面先变为strong变量，并检查是否为nil的处理方式应该更安全。</p>

<p>``` objc
MyObject *object = [[MyObject alloc] init];
object.str = @&ldquo;hoge&rdquo;;</p>

<p>__weak MyObject *weakObject = object;
object.block = ^{</p>

<pre><code>MyObject strongObject = weakObject;
if (strongObject) {
    NSLog(@"block: str=%@", strongObject.str);
}
</code></pre>

<p>};
[object performBlock];
```</p>

<p>总上，当我们使用Blocks时，也需要考虑Block中变量和实例的关系，不要引起不必要的循环参照问题。</p>

<hr />

<h1><span id="5">ARC之Outlet与弱引用</span></h1>

<h3>使用weak property声明Outlet</h3>

<p>当我们使用 Interface Builder 生成Outlet对象的时候，一般都是作为 subview 来使用的。比如 UIViewController 的view。所以说Outlet的持有者就是superview对象，即有“父子”关系。我们知道，当对象间有“父子”关系时，需要使用弱参照，以避免“循环参照”。</p>

<p>ViewController 本身是不会作为Outlet的所有者的，所以使用weak property声明。</p>

<p><img src="/images/arc/arc_outlet_weak_property.png"></p>

<h3>简化viewDidUnload</h3>

<p>Outlet都使用weak property声明的时候，还有一个好处，就是简化viewDidUnload的处理。</p>

<p>iOS在系统内存不足的时候，UIViewController会将没有表示的所有view做unload处理，即调用viewDidUnload接口。</p>

<p>所以，如果是强参照的情况下，需要释放所有权，</p>

<p><code>objc
@property (nonatomic, strong) IBOutlet UILabel *label;
</code></p>

<br>


<p>``` objc
&ndash; (void)viewDidUnload {</p>

<pre><code>self.label = nil; // 取消强参照，释放所有权
[super viewDidUnload];
</code></pre>

<p>}
```</p>

<p>如果没有 self.label = nil 的处理，那么 UIViewController 将不会释放 label 的所有权；结果，系统是调用了unload，但是subview对象始终留在内存中。随着界面上控件的增多，内存泄露会越来越大。</p>

<p>如果使用的是weak property声明的话，会是怎样的呢？</p>

<p><code>objc
@property (nonatomic, weak) IBOutlet UILabel *label;
</code></p>

<p>这时，系统在unload时，由于label没有被强参照，更加ARC的规则，这时，label的对象即被释放。并在释放的同时，变量自动指向nil。</p>

<p>``` objc
&ndash; (void)viewDidUnload {</p>

<pre><code>// 这里什么也不用管
[super viewDidUnload];
</code></pre>

<p>}
```</p>

<p>其实，如果我们的viewDidUnload只是用来释放Outlet用的话，那么该函数也可以不被重载的。</p>

<h3>什么时候要用strong property</h3>

<p>由上我们也可以看到，并不是所有的Outlet都用弱参照来声明都是正确的；当使用Interface Builder生成的第一层的view或者windows被作为Outlet来使用的话，那么是不能声明为弱参照property的。（比如，Storyboard的各个scene）</p>

<p>理由很简单，没有被任何人强参照的对象，生成之后就会立刻被释放。</p>

<p>综上，当我们使用Outlet的时候，注意不同的情况来使用strong或者是weak。</p>

<hr />

<h1><span id="6">ARC之对象转型</span></h1>

<h3>引子</h3>

<p>我们先来看一下ARC无效的时候，我们写id类型转void*类型的写法：</p>

<p><code>objc
id obj = [[NSObject alloc] init];
void *p = obj;
</code></p>

<p>反过来，当把void*对象变回id类型时，只是简单地如下来写，</p>

<p><code>objc
id obj = p;
[obj release];
</code></p>

<p>但是上面的代码在ARC有效时，就有了下面的错误：</p>

<p>``` objc
error: implicit conversion of an Objective-C pointer</p>

<pre><code>   to ’void *’ is disallowed with ARC
   void *p = obj;
             ^
</code></pre>

<p>error: implicit conversion of a non-Objective-C pointer</p>

<pre><code>type ’void *’ to ’id’ is disallowed with ARC
id o = p;
        ^
</code></pre>

<p>```</p>

<h3>__bridge</h3>

<p>为了解决这一问题，我们使用 __bridge 关键字来实现id类型与void*类型的相互转换。看下面的例子。</p>

<p>``` objc
id obj = [[NSObject alloc] init];</p>

<p>void <em>p = (__bridge void </em>)obj;</p>

<p>id o = (__bridge id)p;
```</p>

<p>将Objective-C的对象类型用 <strong>bridge 转换为 void* 类型和使用 </strong>unsafe_unretained 关键字修饰的变量是一样的。被代入对象的所有者需要明确对象生命周期的管理，不要出现异常访问的问题。</p>

<p>除过 <strong>bridge 以外，还有两个 </strong>bridge 相关的类型转换关键字：</p>

<ul>
<li>__bridge_retained</li>
<li>__bridge_transfer</li>
</ul>


<p>接下来，我们将看看这两个关键字的区别。</p>

<h3>__bridge_retained</h3>

<p>先来看使用 __bridge_retained 关键字的例子程序：</p>

<p>``` objc
id obj = [[NSObject alloc] init];</p>

<p>void <em>p = (__bridge_retained void </em>)obj;
```</p>

<p>从名字上我们应该能理解其意义：类型被转换时，其对象的所有权也将被变换后变量所持有。如果不是ARC代码，类似下面的实现：</p>

<p>``` objc
id obj = [[NSObject alloc] init];</p>

<p>void *p = obj;
[(id)p retain];
```</p>

<p>可以用一个实际的例子验证，对象所有权是否被持有。</p>

<p>``` objc
void *p = 0;</p>

<p>{</p>

<pre><code>id obj = [[NSObject alloc] init];
p = (__bridge_retained void *)obj;
</code></pre>

<p>}</p>

<p>NSLog(@&ldquo;class=%@&rdquo;, [(__bridge id)p class]);
```</p>

<p>出了大括号的范围后，p 仍然指向一个有效的实体。说明他拥有该对象的所有权，该对象没有因为出其定义范围而被销毁。</p>

<h3>__bridge_transfer</h3>

<p>相反，当想把本来拥有对象所有权的变量，在类型转换后，让其释放原先所有权的时候，需要使用 __bridge_transfer 关键字。文字有点绕口，我们还是来看一段代码吧。</p>

<p>如果ARC无效的时候，我们可能需要写下面的代码。</p>

<p><code>objc
// p 变量原先持有对象的所有权
id obj = (id)p;
[obj retain];
[(id)p release];
</code></p>

<p>那么ARC有效后，我们可以用下面的代码来替换：</p>

<p><code>objc
// p 变量原先持有对象的所有权
id obj = (__bridge_transfer id)p;
</code></p>

<p>可以看出来，__bridge_retained 是编译器替我们做了 retain 操作，而 __bridge_transfer 是替我们做了 release。</p>

<h3>Toll-Free bridged</h3>

<p>在iOS世界，主要有两种对象：Objective-C 对象和 Core Foundation 对象。Core Foundation 对象主要是有C语言实现的 Core Foundation Framework 的对象，其中也有对象引用计数的概念，只是不是 Cocoa Framework::Foundation Framework 的 retain/release，而是自身的 CFRetain/CFRelease 接口。</p>

<p>这两种对象间可以互相转换和操作，不使用ARC的时候，单纯的用C的类型转换，不需要消耗CPU的资源，所以叫做 Toll-Free bridged。比如 NSArray和CFArrayRef, NSString和CFStringRef，他们虽然属于不同的 Framework，但是具有相同的对象结构，所以可以用标准C的类型转换。</p>

<p>比如不使用ARC时，我们用下面的代码：</p>

<p><code>objc
NSString *string = [NSString stringWithFormat:...];
CFStringRef cfString = (CFStringRef)string;
</code></p>

<p>同样，Core Foundation类型向Objective-C类型转换时，也是简单地用标准C的类型转换即可。</p>

<p>但是在ARC有效的情况下，将出现类似下面的编译错误：</p>

<pre><code>Cast of Objective-C pointer type ‘NSString *’ to C pointer type ‘CFStringRef’ (aka ‘const struct __CFString *’) requires a bridged cast
Use __bridge to convert directly (no change in ownership)
Use __bridge_retained to make an ARC object available as a +1 ‘CFStringRef’ (aka ‘const struct __CFString *’)
</code></pre>

<p>错误中已经提示了我们需要怎样做：用 <strong>bridge 或者 </strong>bridge_retained 来转型，其差别就是变更对象的所有权。</p>

<p>正因为Objective-C是ARC管理的对象，而Core Foundation不是ARC管理的对象，所以才要特意这样转换，这与id类型向void*转换是一个概念。也就是说，当这两种类型（有ARC管理，没有ARC管理）在转换时，需要告诉编译器怎样处理对象的所有权。</p>

<p>上面的例子，使用 <strong>bridge/</strong>bridge_retained 后的代码如下：</p>

<h6>__bridge</h6>

<p><code>objc
NSString *string = [NSString stringWithFormat:...];
CFStringRef cfString = (__bridge CFStringRef)string;
</code></p>

<p>只是单纯地执行了类型转换，没有进行所有权的转移，也就是说，当string对象被释放的时候，cfString也不能被使用了。</p>

<h6>__bridge_retained</h6>

<p><code>objc
NSString *string = [NSString stringWithFormat:...];
CFStringRef cfString = (__bridge_retained CFStringRef)string;
...
CFRelease(cfString); // 由于Core Foundation的对象不属于ARC的管理范畴，所以需要自己release
</code></p>

<p>使用 __bridge_retained 可以通过转换目标处（cfString）的 retain 处理，来使所有权转移。即使 string 变量被释放，cfString 还是可以使用具体的对象。只是有一点，由于Core Foundation的对象不属于ARC的管理范畴，所以需要自己release。</p>

<p>实际上，Core Foundation 内部，为了实现Core Foundation对象类型与Objective-C对象类型的相互转换，提供了下面的函数。</p>

<p>``` objc
CFTypeRef  CFBridgingRetain(id  X)  {</p>

<pre><code>return  (__bridge_retained  CFTypeRef)X;
</code></pre>

<p>}</p>

<p>id  CFBridgingRelease(CFTypeRef  X)  {</p>

<pre><code>return  (__bridge_transfer  id)X;
</code></pre>

<p>}
```</p>

<p>所以，可以用 CFBridgingRetain 替代 __bridge_retained 关键字：</p>

<p><code>objc
NSString *string = [NSString stringWithFormat:...];
CFStringRef cfString = CFBridgingRetain(string);
...
CFRelease(cfString); // 由于Core Foundation不在ARC管理范围内，所以需要主动release。
</code></p>

<h6>__bridge_transfer</h6>

<p>所有权被转移的同时，被转换变量将失去对象的所有权。当Core Foundation对象类型向Objective-C对象类型转换的时候，会经常用到 __bridge_transfer 关键字。</p>

<p>``` objc
CFStringRef cfString = CFStringCreate&hellip;();
NSString <em>string = (__bridge_transfer NSString </em>)cfString;</p>

<p>// CFRelease(cfString); 因为已经用 __bridge_transfer 转移了对象的所有权，所以不需要调用 release
```</p>

<p>同样，我们可以使用 CFBridgingRelease() 来代替 __bridge_transfer 关键字。</p>

<p><code>objc
CFStringRef cfString = CFStringCreate...();
NSString *string = CFBridgingRelease(cfString);
</code></p>

<h3>总结</h3>

<p>由上面的学习我们了解到 ARC 中类型转换的用法，那么我们实际使用中按照怎样的原则或者方法来区分使用呢，下面我总结了几点关键要素。</p>

<ul>
<li>明确被转换类型是否是 ARC 管理的对象</li>
<li>Core Foundation 对象类型不在 ARC 管理范畴内</li>
<li>Cocoa Framework::Foundation 对象类型（即一般使用到的Objectie-C对象类型）在 ARC 的管理范畴内</li>
<li>如果不在 ARC 管理范畴内的对象，那么要清楚 release 的责任应该是谁</li>
<li>各种对象的生命周期是怎样的</li>
</ul>


<p>1 . 声明 id obj 的时候，其实是缺省的申明了一个 __strong 修饰的变量，所以编译器自动地加入了 retain 的处理，所以说 __bridge_transfer 关键字只为我们做了 release 处理。</p>

<hr />

<h1><span id="7">最终归纳</span></h1>

<h3>内存管理基本原则</h3>

<p>内存管理依循下面的基本原则:</p>

<ul>
<li>自己生成的对象，那么即是其持有者</li>
<li>不是自己生成的对象，也可成为其持有者（一个对象可以被多个人持有）</li>
<li>如果不想持有对象的时候，必须释放其所有权</li>
<li>不能释放已不再持有所有权的对象</li>
</ul>


<p><strong>不管ARC有没有效，该原则始终存在。</strong></p>

<h3>所有权关键字</h3>

<p>从代码上看，有ARC的代码和没有ARC的代码区别就在下面的几个关键字。</p>

<p>类似 NSObject* 的对象类型，或者 id 类型(<a href="http://www.yifeiyang.net/iphone-development-introduction-7-from-the-c-c-language-to-objective-c-language/">关于Objective-C对象的解释，可以参考iPhone开发入门（7）— 从C/C++语言到Objective-C语言</a>)，当ARC有效的时候，根据具体情况，这些关键字必须要使用(当然，如果你不写，编译器会用缺省的值代替)。</p>

<ul>
<li>__strong</li>
<li>__weak</li>
<li>__unsafe_unretained</li>
<li>__autoreleasing</li>
</ul>


<p>__strong是默认的修饰符。</p>

<p>__weak修饰了一个自动nil的weak引用。</p>

<p>__unsafe_unretained声明了一个不会自动nil的weak引用。当变量被释放，那么它就变成了一个野指针了。</p>

<p>__autoreleasing 用来修饰一个声明为 (id *) 的函数的参数，当函数返回值时被释放。</p>

<h3>ARC使用准则</h3>

<p>为了避免程序秒退的尴尬，使用ARC时，我们的代码必须遵循下面的准则。</p>

<ul>
<li>不能使用 retain/release/retainCount/autorelease</li>
<li>不能使用 NSAllocateObject/NSDeallocateObject</li>
<li>不能使用 NSZone</li>
<li>不能明示调用dealloc</li>
<li>内存管理相关的函数必须遵循命名规则</li>
<li>使用@autoreleasepool代替NSAutoreleasePool</li>
<li>Objective-C 对象不能作为C语言结构体（struct/union）的成员</li>
<li>【id】与【void*】之间需要明示cast</li>
</ul>


<p>建议使用Objective-C的class来管理数据格式，来代替C语言的struct。不能隐式转换 id 和 void *。</p>

<p>让我们一个一个来分析</p>

<ul>
<li><h4>不能使用 retain/release/retainCount/autorelease</h4></li>
</ul>


<p>内存管理完全交给编译器去做，所以之前内存相关的函数(retain/release/retainCount/autorelease)不能出现在程序中。Apple的ARC文档中也有下面的说明。</p>

<pre><code>ARC 有效后，不需要再次使用retain 和 release
</code></pre>

<p>如果我们在程序中使用这些函数，会得到类似下面的编译错误信息。</p>

<pre><code>error: ARC forbids explicit message send of ’release’
     [o release];
      ^ ~~~~~~~
</code></pre>

<ul>
<li><h4>不能使用 NSAllocateObject/NSDeallocateObject</h4></li>
</ul>


<p>生成并持有一个Objective-C对象的时候，往往像下面一样使用NSObject的alloc接口函数。</p>

<p><code>objc
id obj = [NSObject alloc];
</code></p>

<p>实际上，如果我们看了GNUstep 中关于 alloc 的代码就会明白，实际他是使用 NSAllocateObject 来生成并持有对象实例的。换言之，ARC有效的时候，NSAllocateObject函数的调用也是禁止的。如果使用，也会遇到下面的编译错误。</p>

<pre><code>error: ’NSAllocateObject’ is unavailable:
    not available in automatic reference counting mode
</code></pre>

<p>同样，对象释放时使用的 NSDeallocateObject 函数也不能使用。</p>

<ul>
<li><h4>不能使用 NSZone</h4></li>
</ul>


<p>NSZone 是什么？NSZone 是为了防止内存碎片而导入的一项措施。Zone 是内存管理的基本单元，系统中管理复数的Zone。系统根据对象的使用目的，尺寸，分配其所属的Zone区域。以提高对象的访问效率，避免不必要的内存碎片。但是，现在的运行时系统（用编译开关 __OBJC2__ 指定的情况下）是不支持Zone概念的。所以，不管ARC是否有效，都不能使用 NSZone。</p>

<ul>
<li><h4>不能明示调用dealloc</h4></li>
</ul>


<p>不管是否使用ARC，当对象被释放的时候，对象的dealloc函数被调用（就像是C++中对象的析构函数）。在该函数中，需要做一些内存释放的动作。比如，当对象中使用了malloc分配的C语言内存空间，那么dealloc中就需要像下面一样处理内存的释放。</p>

<p>``` objc
&ndash; (void) dealloc
{</p>

<pre><code>free(buffer_);
</code></pre>

<p>}
```</p>

<p>又或者是注册的delegate对象，观察者对象需要被删除的时候，也是在dealloc函数中动作。</p>

<p>``` objc
&ndash; (void) dealloc
{</p>

<pre><code>[[NSNotificationCenter defaultCenter] removeObserver:self];
</code></pre>

<p>}
```</p>

<p>如果在ARC无效的时候，我们还要像下面一样，调用父类对象的dealloc函数。</p>

<p>``` objc
&ndash; (void) dealloc
{</p>

<pre><code>[super dealloc];
</code></pre>

<p>}
```</p>

<p>但是当ARC有效的时候，[super dealloc];的调用已经被编译器自动执行，已经不需要我们明示调用了。如果你在代码中还这样写，难免遇到下面的错误。</p>

<pre><code>error: ARC forbids explicit message send of ’dealloc’
     [super dealloc];
      ^ ~~~~~~~
</code></pre>

<ul>
<li><h4>内存管理相关的函数必须遵循命名规则</h4></li>
</ul>


<p>在前面，我们知道如果是 alloc/new/copy/mutableCopy/init 开头的函数，需要将对象所有权返回给调用端。这条规则不管ARC是否有效都应该被遵守。只是 init 开头的函数比较特殊，他只在ARC下有要求，而且异常苛刻。</p>

<p>init 开始的函数只能返回id型，或者是该函数所属的类/父类的对象类型。基本上来说，init函数是针对alloc函数的返回值，做一些初始化处理，然后再将该对象返回。比如：</p>

<p><code>objc
id obj = [[NSObject alloc] init];
</code></p>

<p>再比如下面定义的函数就是不对的：</p>

<p><code>objc
- (void) initThisObject;
</code></p>

<p>需要是下面这样：</p>

<p><code>objc
- (id) initWithObject:(id)obj;
</code></p>

<p>另外，下面名为 initialize 的函数比较特殊，编译器将把它过滤掉，不按上面的规则处理。</p>

<ul>
<li><h4>使用@autoreleasepool代替NSAutoreleasePool</h4></li>
</ul>


<p>在ARC之下，已经不能在代码中使用 NSAutoreleasePool，我们之前写 main.m 文件的时候，往往像下面这样写。</p>

<p>``` objc
int main(int argc, char *argv[]) {</p>

<pre><code>NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
int retVal = UIApplicationMain(argc, argv, nil, nil);
[pool release];
return retVal;
</code></pre>

<p>}
```
而当ARC有效后，我们需要用@autoreleasepool代替NSAutoreleasePool。</p>

<p>``` objc
int main(int argc, char *argv[])
{</p>

<pre><code>@autoreleasepool {
    return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
}
</code></pre>

<p>}
```</p>

<p>当编译器看到 @autoreleasepool 定义的块后会自动生成 NSAutoreleasePool 对象，并将需要的对象放入 AutoReleasePool 中，当出方块的定义范围时，pool 中的对象将被释放。</p>

<ul>
<li><h4>Objective-C 对象不能作为C语言结构体（struct/union）的成员</h4></li>
</ul>


<p>当我们设置ARC有效，并在C语言的结构体中定义Objective-C的对象时，将出现类似下面的编译错误。</p>

<p>``` objc
struct Data {</p>

<pre><code>NSMutableArray *array;
</code></pre>

<p>};
```</p>

<br>


<pre><code>error: ARC forbids Objective-C objs in structs or unions
     NSMutableArray *array;
                     ^
</code></pre>

<p>由于 ARC 是将内存管理的细节委托给编译器来做，所以说编译器必须要管理对象的生命周期。而LLVM 3.0中不存在对单纯C语言构造体成员的内存管理方法。如果单纯是栈对象，利用进出栈原理，可以简单地维护对象的生命周期；而结构体是不行的，简单地理解，结构体没有析构函数，编译器自身不能自动释放其内部的 Objective-C 对象。</p>

<p>当我们必须在C语言的结构体中放入 Objective-C 对象的时候，可以使用 void* 转型，或者使用 __unsafe_unretained 关键字。比如下面：</p>

<p>``` objc
struct Data {</p>

<pre><code>NSMutableArray __unsafe_unretained *array;
</code></pre>

<p>};
```</p>

<p>这样一来，该内存信息不在编译器内存管理对象内，仅仅是使用而已，没有对象的持有权。当然，对象所有权的持有者需要明确的管理他与该结构体的交互，不要引起不必要的错误(关于这一点，可以参考<a href="http://www.yifeiyang.net/development-of-the-iphone-simply-1/">iPhone开发之深入浅出 (1) — ARC是什么</a> 一文，明白为什么 __unsafe_unretained 是危险的)。</p>

<ul>
<li><h4>[id]与[void*]之间需要明示cast</h4></li>
</ul>


<p>ARC 有效的时候，由于编译器帮我们做了内存管理的工作，所以我们不需要太担心。但是当与 ARC 管理以外的对象类型交互的时候，就需要特殊的转型关键字，来决定所有权的归属问题。</p>

<p>主要的转型关键字是:</p>

<table border="1">
<thead>
    <tr>
        <th>关键字</th>
        <th>解释</th>
    </tr>
</thead>
<tbody>
    <tr>
        <td>__bridge</td>
        <td>单纯的类型转换，没有进行所有权的转移</td>
    </tr>
    <tr>
        <td>__bridge_retained</td>
        <td>类型转换是伴随所有权传递，转换前后变量都持有对象的所有权</td>
    </tr>
    <tr>
        <td>__bridge_transfer</td>
        <td>类型转换伴随所有权转移，被转换变量将失去对象的所有权</td>
    </tr>
</tbody>
</table>


<p>当我们在 Core Foundation 对象类型与 Objective-C 对象类型之间切换的时候，需要把握下面的因素：</p>

<ul>
<li>明确被转换类型是否是 ARC 管理的对象</li>
<li>Core Foundation 对象类型不在 ARC 管理范畴内</li>
<li>Cocoa Framework::Foundation 对象类型（即一般使用到的Objectie-C对象类型）在 ARC 的管理范畴内</li>
<li>如果不在 ARC 管理范畴内的对象，那么要清楚 release 的责任应该是谁</li>
<li>各种对象的生命周期是怎样的</li>
</ul>


<h3>为什么iOS中没有GC</h3>

<p>我们已经知道ARC并不是GC（垃圾回收）了，那么，为什么iOS中不支持该机能呢？还特意搞出个ARC来。以下是我的分析：</p>

<ul>
<li>消耗CPU时间的处理尽量避免，以节约电池电量</li>
<li>GC执行的时候，会停掉运行时库；这是最大的心结</li>
<li>嵌入式设备本身内存就不是很大，如果GC不停的在后台运行，执行的频率会很高，严重影响性能</li>
<li>UI动画处理是iOS的一大卖点，而有了GC后可能会引起不必要的性能损失</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS的多线程原理、分类与应用]]></title>
    <link href="http://gbammc.github.io/blog/2013/10/06/iosde-duo-xian-cheng-fen-lei-yu-ying-yong/"/>
    <updated>2013-10-06T23:58:00+08:00</updated>
    <id>http://gbammc.github.io/blog/2013/10/06/iosde-duo-xian-cheng-fen-lei-yu-ying-yong</id>
    <content type="html"><![CDATA[<p>今天查资料才发现，iOS中的线程使用不是无限制的，官方文档给出的<a href="https://developer.apple.com/library/mac/documentation/cocoa/conceptual/Multithreading/CreatingThreads/CreatingThreads.html">资料</a>显示iOS下的主线程堆栈大小是1M，第二个线程开始都是512KB，并且该值不能通过编译器开关或线程API函数来更改。另外只有主线程有直接修改UI的能力。所以也学习并总结下iOS的多线程编程来加深下吧。</p>

<!-- more -->


<ul>
<li><a href="#runloop">关于RunLoopg</a></li>
<li><a href="#nsthread">NSThread</a></li>
<li><a href="#nsoperation">NSOperationQueue和NSOperation</a></li>
<li><a href="#gcd">GCD</a></li>
<li><a href="#compare">NSOperationQueue与GCD的对比</a></li>
</ul>


<hr />

<h2><span id="runloop">关于RunLoop</span></h2>

<p>首先关于RunLoop，iOS中的RunLoop准确的说是线程中的循环。首先循环体的开始需要检测是否有需要处理的事件，如果有则去处理，如果没有则进入睡眠以节省CPU时间。 所以重点便是这个需要处理的事件，在RunLoop中，需要处理的事件分两类，一种是输入源，一种是定时器。定时器好理解，就是那些需要定时执行的操作;输入源分三类：performSelector源，基于端口（Mach port）的源，以及自定义的源。而RunLoop在每一次循环的开始便去检查这些事件源是否有需要处理的数据，有的话则去处理。</p>

<p>系统会自动为应用程序的主线程生成一个与之对应的 run loop 来处理其消息循环。在触摸 UIView 时之所以能够激发 touchesBegan/touchesMoved 等等函数被调用，就是因为应用程序的主线程在 UIApplicationMain 里面有这样一个 run loop 在分发 input 或 timer 事件。</p>

<p>而每一个线程都有其对应的RunLoop，但是默认非主线程的RunLoop是没有运行的，需要为RunLoop添加至少一个事件源，然后去run它。一般情况下我们是没有必要去启用线程的RunLoop的，除非你在一个单独的线程中需要长久的检测某个事件。</p>

<hr />

<h2><span id="multi-thread">多线程编程</span></h2>

<p>iOS中的多线程编程主要分以下三类：1.NSThread;2.NSOperation/NSOperationQueue;3.GCD。后两者其实都是对NSThreads的调用再进行一次封装，以便开发人员更容易使用iOS中的多线程编程。而对于NSOperation/NSOperationQueue和GCD的比较，支持者们意见不太统一，应该适时选择合适的。这里也附上StackOverflow上的<a href="http://stackoverflow.com/questions/10373331/nsoperation-vs-grand-central-dispatch">讨论</a>(本文后面也有列出大概原因)情况。</p>

<h3><span id="nsthread">NSThread</span></h3>

<ul>
<li>优点：NSThread比其他两个轻量级</li>
<li>缺点：需要自己管理线程的生命周期，线程同步。线程同步对数据的加锁会有一定的系统开销</li>
</ul>


<p><strong>NSThread的使用</strong></p>

<p>``` objc
&ndash; (id)initWithTarget:(id)target selector:(SEL)selector object:(id)argument
+ (void)detachNewThreadSelector:(SEL)aSelector toTarget:(id)aTarget withObject:(id)anArgument</p>

<p>```</p>

<p>第一个是实例方法，第二个是类方法</p>

<p>``` objc
// 类方法
[NSThread detachNewThreadSelector:@selector(doSomething:) toTarget:self withObject:nil];</p>

<p>// 实例方法的声明
NSThread* myThread = [[NSThread alloc] initWithTarget:self</p>

<pre><code>                                    selector:@selector(doSomething:)
                                    object:nil];
</code></pre>

<p>// 实例方法的调用
[myThread start];
```</p>

<p>这两种方式的区别是：前一种一调用就会立即创建一个线程来做事情;而后一种虽然你alloc了也init了，但是要直到我们手动调用 <code>start</code> 启动线程时才会真正去创建线程。这种延迟实现思想在很多跟资源相关的地方都有用到。后一种方式我们还可以在启动线程之前，对线程进行配置，比如设置stack大小，线程优先级。</p>

<p>还有一种间接的方式，更加方便，我们甚至不需要显式编写NSThread相关代码。那就是利用NSObject的类方法 <code>performSelectorInBackground:withObject:</code> 来创建一个线程：</p>

<p><code>objc
[myObj performSelectorInBackground:@selector(myThreadMainMethod) withObject:nil];
</code></p>

<p>其效果与NSThread的 <code>detachNewThreadSelector:toTarget:withObject:</code> 是一样的</p>

<p><strong>线程同步</strong></p>

<p>线程的同步方法跟其他系统下类似，我们可以用原子操作，可以用mutex，lock等。</p>

<p>iOS的原子操作函数是以OSAtomic开头的，比如：OSAtomicAdd32, OSAtomicOr32等等。这些函数可以直接使用，因为它们是原子操作。</p>

<p>iOS中的mutex对应的是NSLock，它遵循 NSLooking协议，我们可以使用lock, tryLock, lockBeforeData:来加锁，用unLock来解锁。使用示例：</p>

<p>``` objc
BOOL moreToDo = YES;
NSLock *theLock = [[NSLock alloc] init];
&hellip;
while (moreToDo) {</p>

<pre><code>/* Do another increment of calculation */
/* until there’s no more to do. */
if ([theLock tryLock]) {
    /* Update display used by all threads. */
    [theLock unlock];
}
</code></pre>

<p>}
```</p>

<p>我们可以使用指令 @synchronized 来简化 NSLock的使用，这样我们就不必显示编写创建NSLock,加锁并解锁相关代码。</p>

<p>``` objc
&ndash; (void)myMethod:(id)anObj
{</p>

<pre><code>@synchronized(anObj)
{
    // Everything between the braces is protected by the @synchronized directive.
}
</code></pre>

<p>}
```</p>

<p>还有其他的一些锁对象，比如：循环锁NSRecursiveLock，条件锁NSConditionLock，分布式锁NSDistributedLock等等，在这里就不一一介绍了。</p>

<p><strong>用NSCodition同步执行的顺序</strong></p>

<p>NSCodition是一种特殊类型的锁，我们可以用它来同步操作执行的顺序。它与mutex的区别在于更加精准，等待某个NSCondtion的线程一直被lock，直到其他线程给那个condition发送了信号。下面我们来看使用示例：</p>

<p>``` objc
// 某个线程等待着事情去做，而有没有事情做是由其他线程通知它的
[cocoaCondition lock];
while (timeToDoWork &lt;= 0) [cocoaCondition wait];</p>

<p>timeToDoWork&mdash;;
// Do real work here.</p>

<p>[cocoaCondition unlock];</p>

<p>//其他线程发送信号通知上面的线程可以做事情了：
[cocoaCondition lock];
timeToDoWork++;
[cocoaCondition signal];
[cocoaCondition unlock];
```</p>

<p><strong>线程间通信</strong></p>

<p>线程在运行过程中，可能需要与其它线程进行通信。我们可以使用 NSObject 中的一些方法：</p>

<p>``` objc
// 在应用程序主线程中做事情：
performSelectorOnMainThread:withObject:waitUntilDone:
performSelectorOnMainThread:withObject:waitUntilDone:modes:</p>

<p>// 在指定线程中做事情：
performSelector:onThread:withObject:waitUntilDone:
performSelector:onThread:withObject:waitUntilDone:modes:</p>

<p>// 在当前线程中做事情：
performSelector:withObject:afterDelay:
performSelector:withObject:afterDelay:inModes:</p>

<p>// 取消发送给当前线程的某个消息
cancelPreviousPerformRequestsWithTarget:
cancelPreviousPerformRequestsWithTarget:selector:object:
```</p>

<p>如在我们在某个线程中下载数据，下载完成之后要通知主线程中更新界面等等，可以使用如下接口：</p>

<p>``` objc
&ndash; (void)callMainThreadMethod
{</p>

<pre><code>NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
// to do something in your thread job
...
[self performSelectorOnMainThread:@selector(updateUI) withObject:nil waitUntilDone:NO];
[pool release];
</code></pre>

<p>}
```</p>

<p><strong>隐式调用</strong></p>

<p>用NSObject的类方法<code>performSelectorInBackground:withObject:</code>创建一个线程：</p>

<p><code>objc
[myObj performSelectorInBackground:@selector(doSomething) withObject:nil];
</code></p>

<hr />

<h3><span id="nsoperation">NSOperationQueue和NSOperation</span></h3>

<p>多线程编程是防止主线程堵塞，增加运行效率等等的最佳方法。而原始的多线程方法存在很多的毛病，包括线程锁死等。在Cocoa中，Apple提供了NSOperation这个类，提供了一个优秀的多线程编程方法。</p>

<p>NSOperationQueue会建立一个线程管理器，每个加入到线程operation会有序的执行。</p>

<p>用NSOperationQueue的过程：</p>

<ol>
<li>建立一个NSOperationQueue的对象</li>
<li>建立一个NSOperation的对象</li>
<li>将operation加入到NSOperationQueue中</li>
<li>release掉operation</li>
</ol>


<p>本次介绍NSOperation的子集，简易方法的NSInvocationOperation：</p>

<p>``` objc
@implementation MyCustomClass
&ndash; (void)launchTaskWithData:(id)data
{</p>

<pre><code>//创建一个NSInvocationOperation对象，并初始化到方法
//在这里，selector参数后的值是你想在另外一个线程中运行的方法（函数，Method）
//在这里，object后的值是想传递给前面方法的数据
NSInvocationOperation* theOp = [[NSInvocationOperation alloc] initWithTarget:self
                selector:@selector(myTaskMethod:) object:data];
// 下面将我们建立的操作“Operation”加入到本地程序的共享队列中（加入后方法就会立刻被执行）
// 更多的时候是由我们自己建立“操作”队列
[[MyAppDelegate sharedOperationQueue] addOperation:theOp];
</code></pre>

<p>}
// 这个是真正运行在另外一个线程的“方法”
&ndash; (void)myTaskMethod:(id)data
{</p>

<pre><code>// Perform the task.
</code></pre>

<p>}
@end
```</p>

<p>一个NSOperationQueue操作队列，就相当于一个线程管理器，而非一个线程。因为你可以设置这个线程管理器内可以并行运行的的线程数量等等。下面是建立并初始化一个操作队列：</p>

<p>``` objc
@interface MyViewController : UIViewController {</p>

<pre><code>NSOperationQueue *operationQueue;
//在头文件中声明该队列
</code></pre>

<p>}
@end
@implementation MyViewController
&ndash; (id)init
{</p>

<pre><code>self = [super init];
if (self) {
    operationQueue = [[NSOperationQueue alloc] init]; //初始化操作队列
    [operationQueue setMaxConcurrentOperationCount:1];
    //在这里限定了该队列只同时运行一个线程
    //这个队列已经可以使用了
}
return self;
</code></pre>

<p>}
&ndash; (void)dealloc
{</p>

<pre><code>[operationQueue release];
//正如Alan经常说的，我们是程序的好公民，需要释放内存！
[super dealloc];
</code></pre>

<p>}
@end
```</p>

<hr />

<h3><span id="gcd">GCD</span></h3>

<p>GCD是一个替代诸如NSThread, NSOperationQueue, NSInvocationOperation等技术的很高效和强大的技术，它看起来象就其它语言的闭包(Closure)一样，但苹果把它叫做blocks。</p>

<h4>GCD的定义</h4>

<p>简单GCD的定义有点象函数指针，差别是用 ^ 替代了函数指针的 * 号，如下所示：</p>

<p>``` objc
// 申明变量
 (void) (^loggerBlock)(void);
 // 定义
 loggerBlock = ^{</p>

<pre><code>  NSLog(@"Hello world"); 
</code></pre>

<p> };
 // 调用
 loggerBlock();
```</p>

<p>但是大多数时候，我们通常使用内联的方式来定义它，即将它的程序块写在调用的函数里面，例如这样：</p>

<p>``` objc
dispatch_async(dispatch_get_global_queue(0, 0), ^{</p>

<pre><code> // something 
</code></pre>

<p>});
```</p>

<p>从上面大家可以看出，block有如下特点：</p>

<p>程序块可以在代码中以内联的方式来定义。
程序块可以访问在创建它的范围内的可用的变量。</p>

<p>系统提供的dispatch方法</p>

<p>为了方便地使用GCD，苹果提供了一些方法方便我们将block放在主线程 或 后台线程执行，或者延后执行。使用的例子如下：</p>

<p>``` objc
//  后台执行：
 dispatch_async(dispatch_get_global_queue(0, 0), ^{</p>

<pre><code>  // something 
</code></pre>

<p> });
 // 主线程执行：
 dispatch_async(dispatch_get_main_queue(), ^{</p>

<pre><code>  // something 
</code></pre>

<p> });
 // 一次性执行：
 static dispatch_once_t onceToken;
 dispatch_once(&amp;onceToken, ^{</p>

<pre><code> // code to be executed once 
</code></pre>

<p> });
 // 延迟2秒执行：
 double delayInSeconds = 2.0;
 dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, delayInSeconds * NSEC_PER_SEC);
 dispatch_after(popTime, dispatch_get_main_queue(), ^(void){</p>

<pre><code> // code to be executed on the main queue after delay 
</code></pre>

<p> });
// dispatch_queue_t 也可以自己定义，如要要自定义queue，可以用dispatch_queue_create方法，示例如下：</p>

<p>dispatch_queue_t urls_queue = dispatch_queue_create(&ldquo;blog.devtang.com&rdquo;, NULL);
dispatch_async(urls_queue, ^{</p>

<pre><code> // your code 
</code></pre>

<p>});
dispatch_release(urls_queue);
```</p>

<p><strong>后台运行</strong></p>

<p>GCD的另一个用处是可以让程序在后台较长久的运行。在没有使用GCD时，当app被按home键退出后，app仅有最多5秒钟的时候做一些保存或清理资源的工作。但是在使用GCD后，app最多有10分钟的时间在后台长久运行。这个时间可以用来做清理本地缓存，发送统计数据等工作。</p>

<p>另外，GCD还有一些高级用法，例如让后台2个线程并行执行，然后等2个线程都结束后，再汇总执行结果。这个可以用dispatch_group, dispatch_group_async 和 dispatch_group_notify来实现，示例如下：</p>

<p>``` objc
dispatch_group_t group = dispatch_group_create();
dispatch_group_async(group, dispatch_get_global_queue(0,0), ^{</p>

<pre><code>  // 并行执行的线程一 
</code></pre>

<p> });
 dispatch_group_async(group, dispatch_get_global_queue(0,0), ^{</p>

<pre><code>  // 并行执行的线程二 
</code></pre>

<p> });
 dispatch_group_notify(group, dispatch_get_global_queue(0,0), ^{</p>

<pre><code>  // 汇总结果 
</code></pre>

<p> });
```
让程序在后台长久运行的示例代码如下:</p>

<p>``` objc
// AppDelegate.h文件
@property (assign, nonatomic) UIBackgroundTaskIdentifier backgroundUpdateTask;</p>

<p>// AppDelegate.m文件
&ndash; (void)applicationDidEnterBackground:(UIApplication *)application
{</p>

<pre><code>[self beingBackgroundUpdateTask]; 
// 在这里加上你需要长久运行的代码 
[self endBackgroundUpdateTask]; 
</code></pre>

<p>}</p>

<ul>
<li><p>(void)beingBackgroundUpdateTask
{
  self.backgroundUpdateTask = [[UIApplication sharedApplication] beginBackgroundTaskWithExpirationHandler:^{
      [self endBackgroundUpdateTask];
  }];
}</p></li>
<li><p>(void)endBackgroundUpdateTask
{
  [[UIApplication sharedApplication] endBackgroundTask: self.backgroundUpdateTask];
  self.backgroundUpdateTask = UIBackgroundTaskInvalid;
}
```</p></li>
</ul>


<h2><span id="compare">NSOperationQueue与GCD的对比</span></h2>

<p>对于NSOperationQueue和GCD应该用哪个，一般来说可以用编程界比较通用的原则来决定：</p>

<pre><code>Always use the highest-level abstraction available to you, and drop down to lower-level abstractions when measurement shows that they are needed.
</code></pre>

<p>简意是：尽可能用更高级抽象的方法。但前面提到的StackOverflow里的讨论里却分别说出了两者的优缺点：</p>

<p><strong>NSOperation好处：</strong></p>

<ul>
<li>很容易设置两个NSOperation之间的依赖来让某一个操作在上一个操作完成后才执行</li>
<li>方便设置在同一时间运行的操作个数</li>
<li><p>您可以创建操作,支持在第一时间被取消</p></li>
<li><p>bandwidth-constrained queues that only run N operations at a time</p></li>
<li>establishing dependencies between operations</li>
<li>you can create operations that support being cancelled in the first place</li>
</ul>


<p><strong>GCD好处：</strong></p>

<ul>
<li>NSOperation对象在创建或释放过程中会消耗明显的CPU资源</li>
<li><p>使用Blocks后代码比使用NSOperation更简洁</p></li>
<li><p>The NSOperation object allocation and deallocation process took a significant amount of CPU resources when dealing with small and frequent actions, like rendering an OpenGL ES frame to the screen. GCD blocks completely eliminated that overhead, leading to significant performance improvements.</p></li>
<li>code is cleaner when using blocks than NSOperations.</li>
</ul>


<p>当然，具体使用哪一个还是要看你的使用场合了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TheOS越狱开发]]></title>
    <link href="http://gbammc.github.io/blog/2013/10/04/theosyue-yu-kai-fa/"/>
    <updated>2013-10-04T22:45:00+08:00</updated>
    <id>http://gbammc.github.io/blog/2013/10/04/theosyue-yu-kai-fa</id>
    <content type="html"><![CDATA[<p>因为最近对越狱开发感兴趣起来，所以果断利用Google去找资料，结果发现相关的东西却是少之又少，于是想如果我能在这个摸爬过程中学到一些东西的话，就都把它整理post出来，让更多有兴趣的人也能参与当中。</p>

<p>而对于越狱开发，我是这么认为的：为了利用iOS系统私有的API，你不得不去挖掘系统底层的东西，在这个过程中，你又会加深对整个系统的了解，从而将自己的开发水平提升一个档次。虽然苹果不会鼓励这样做，不过也是一条有乐趣的学习之道吧。</p>

<!-- more -->


<hr />

<h3>1.TheOS环境搭建</h3>

<p><a href="http://brandontreb.com/beginning-jailbroken-ios-development-your-first-tweak">http://brandontreb.com/beginning-jailbroken-ios-development-your-first-tweak</a>
这是国外很全面的TheOS环境搭建和打包工具安装以及一个简单TheOS程序示例，英语比较好的同学可以参照这一篇。</p>

<p>安装theos主要步骤如下：</p>

<p><code>bash
$ export THEOS=/opt/theos
$ git clone git://github.com/DHowett/theos.git $THEOS
$ sudo chmod -Rf 777 $THEOS
$ curl -s http://dl.dropbox.com/u/3157793/ldid &gt; $THEOS/bin/ldid
$ chmod 777 $THEOS/bin/ldid
$ cd $THEOS/include/IOSurface
$ sudo curl -O -k https://raw.github.com/javacom/toolchain4/master/Projects/IOSurfaceAPI.h
</code></p>

<p>这样就完成TheOS的安装了。</p>

<p>另外还需要下载一个class-dump工具包，用于导出苹果库中的私有头文件:
<a href="https://github.com/nygard/class-dump">https://github.com/nygard/class-dump</a>
，或者也可以直接使用rpetrich大神的<a href="https://github.com/rpetrich/iphoneheaders">头文件库</a>。把得到的头文件解压并放到$THEOS/include中即可。</p>

<hr />

<h3>2.打包工具</h3>

<h4>1)安装Macports</h4>

<p>如果已经安装了那么可以忽略这一步，查看是否已经安装可以输入如下指令：</p>

<p><code>bash
$ port version
</code></p>

<p>官方下载传送门：<a href="http://www.macports.org/install.php">http://www.macports.org/install.php</a></p>

<h4>2)安装dpkg</h4>

<p>安装dpkg的命令</p>

<p><code>bash
$ sudo port install dpkg
</code></p>

<hr />

<h3>3.TheOS生成的Makefile文件剖析</h3>

<p><code>bash
include theos/makefiles/common.mk
</code></p>

<p>告诉TheOS在编译脚本仲包括共同的make命令，避免做重复的make编译工作</p>

<p><code>bash
TWEAK_NAME = HelloWorld
</code></p>

<p>我们要变异的应用程序的名称。Makefile将会用这个常量在内部做一些事情。除非你的应用程序改名称，否则不要修改这个值。</p>

<p><code>bash    
[TWEAK_NAME]_FILES = Tweak.xm
</code></p>

<p>这里是需要编译的文件列表。注意：不要把头文件添加到这里。如果你要添加一个新的.m或者.mm文件到项目中，确保在这里添加新的文件名称，否则将不会建立编译连接。</p>

<p><code>bash
[TWEAK_NAME]_FRAMEWORKS = UIKit Foundation
</code></p>

<p>这里包括你想用到框架的名称</p>

<p><code>bash
include $(THEOS_MAKE_PATH)/application.mk
</code></p>

<p>更多默认的用于帮助TheOS建立项目</p>

<hr />

<h3>4.第一个HelloWorld后台程序</h3>

<p>在终端中输入：</p>

<p>``` bash  <br/>
$ export THEOS=/opt/theos/
$ export SDKVERSION=5.1         // sdk版本号
$ $THEOS/bin/nic.pl             // 执行TheOS</p>

<h2>NIC 2.0 &ndash; New Instance Creator</h2>

<pre><code>[1.] iphone/application
[2.] iphone/cydget
[3.] iphone/dashboardx_widget
[4.] iphone/framework
[5.] iphone/library
[6.] iphone/notification_center_widget
[7.] iphone/preference_bundle
[8.] iphone/sbsettingstoggle
[9.] iphone/tool
[10.] iphone/tweak
</code></pre>

<p>Choose a Template (required): 10
Project Name (required): HelloWorld
Package Name [com.yourcompany.helloworld]:
Author/Maintainer Name [Alvin]:
[iphone/tweak] MobileSubstrate Bundle filter    [com.apple.springboard]:
Instantiating iphone/tweak in helloworld/&hellip;
Done.
```</p>

<p>我们创建一个后台程序，要做的是当系统开机时候弹出HelloWorld字样的Alert框。</p>

<p>打开Tweak.xm文件，清空后添加以下代码</p>

<p>``` objc</p>

<h1>import &lt;UIKit/UIKit.h></h1>

<p>%hook SpringBoard</p>

<p>&ndash;(void)applicationDidFinishLaunching:(id)application {</p>

<pre><code>%orig;

UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"Welcome" 
    message:@"Welcome to your iPhone Brandon!" 
    delegate:nil 
    cancelButtonTitle:@"Thanks" 
    otherButtonTitles:nil];
[alert show];
[alert release];
</code></pre>

<p>}</p>

<p>%end</p>

<p>```</p>

<p>因为我们要用到hook（钩子）钩取系统开机时候调用的其中一个函数，在那个函数中插入我们的Alert。%orig;功能是执行这个函数原来的动作。如果你想完完全全禁止某个函数的功能，不使用 %orig;即可。</p>

<p>然后打开Makefile文件添加</p>

<p><code>bash
HelloWorld_FRAMEWORKS = UIKit
</code></p>

<hr />

<h3>5.编译和安装</h3>

<p>至此，便到了编译和安装的步骤：</p>

<p><strong>1.利用ssh安装</strong></p>

<p>首先export iPhone的ip：</p>

<p><code>bash
$ export THEOS_DEVICE_IP=192.168.1.115
</code></p>

<p>然后输入：</p>

<p><code> bash
$ make install
</code></p>

<p>在运行过程中可能会多次要求输入密码，默认是alpine。安装完成后，你的设备就会自动重启，并且会显示你自定义的信息。</p>

<p><strong>2.自行打包手动安装</strong></p>

<p>打开控制台，进入到你的这个工程文件夹，使用命令</p>

<p><code>bash
make
make package
</code></p>

<p>然后会生成一个com.yourcompany.fooproject_0.0.1-1_iphoneos-arm.deb这样的包在你的目录中，</p>

<p>然后利用iFunbox，iTools等工具将改包放到/private/var/root/Media/Cydia/AutoInstall/中，那么就会自动安装。</p>

<p>或者也可以使用iFiles手动安装。</p>

<hr />

<h3>PS：</h3>

<p>在输入make install后可能会出现一下几种情况：</p>

<h5>1.ssh Connection refused</h5>

<p><code>bash
ssh: connect to host 192.168.1.115 port 22: Connection refused
lost connection
</code></p>

<p>这是因为你还没有打开ssh，在SBSettings里的开关中你应该见到对应的开关。</p>

<h5>2.Connection closed by remote host</h5>

<p>从Cydia里安装SBSettings和OpenSSH后，如果在终端里输入</p>

<p><code>bash
ssh root@192.168.1.115          // iPhone和Mac处于同一网络下
</code></p>

<p>后，出现</p>

<p><code>bash
ssh_exchange_identification: Connection closed by remote host
</code></p>

<p>那么应该立刻使用iFunBox等软件进入iPhone的文件系统，并删除以下内容</p>

<p><code>
/System/Library/LaunchDaemons/com.ikey.bbot.plist
/bin/poc-bbot
</code></p>

<p>然后重新安装OpenSSH。</p>

<p>出现以上问题，说明你的iPhone已经中了名叫ikee的病毒，所以如果装了OpenSSH后，应该立刻改掉你的root密码，默认是alpine。例如在Cydia安装Mobile Terminal，然后输入</p>

<p><code>bash
$ su
// 输入密码如：alpine
$ passwd root   // 输入新密码
</code></p>

<p>参考资料：<a href="http://hi.baidu.com/celavi/item/83c5c68e241b5cd55f0ec1ad">[iPhone]OpenSSH连不上：ssh_exchange_identification: Connection closed by remote host</a></p>

<h5>3.collect2: ld terminated with signal 6 [Abort trap: 6]</h5>

<p>出现如下错误：</p>

<p><code>bash
Making all for tweak PreferenceLoader...
Preprocessing Tweak.xm...
Compiling Tweak.xm...
Linking tweak PreferenceLoader...
collect2: ld terminated with signal 6 [Abort trap: 6]
ld(8724,0x7fff78fd2960) malloc: *** error for object 0x7f89b35003f0: pointer being freed was not allocated
*** set a breakpoint in mallocerror_break to debug
make[2]: *** [obj/PreferenceLoader.dylib] Error 1
make[1]: *** [internal-library-all] Error 2
make: *** [PreferenceLoader.all.tweak.variables] Error 2
</code></p>

<p>那是因为Xcode4.5附带的两个不同版本的链接器。一个用于gcc来编译armv6架构，另一个clang则不会产生armv6的输出。现在没有理由用6.0的SDK去targetiOS4.3以下的系统，或其它基于armv6的平台。我们可以在Makefile最顶部加上如下两句：</p>

<p><code>
export ARCHS=armv7
export TARGET=iphone:latest:4.3
</code></p>

<p>另外，如果要兼容低版本那么可以替换为：</p>

<p><code>
export ARCHS=armv6 armv7
export TARGET=iphone:&lt;sdkversion-lower-than-6.0&gt;:&lt;deployment target-higher-than-3.0&gt;
</code></p>
]]></content>
  </entry>
  
</feed>
