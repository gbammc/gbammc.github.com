<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Alvin Zhu]]></title>
  <link href="http://gbammc.github.io/atom.xml" rel="self"/>
  <link href="http://gbammc.github.io/"/>
  <updated>2014-08-26T13:31:09+08:00</updated>
  <id>http://gbammc.github.io/</id>
  <author>
    <name><![CDATA[Alvin Zhu]]></name>
    <email><![CDATA[gbammc@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[关于 Token，你应该知道的十件事]]></title>
    <link href="http://gbammc.github.io/blog/2014/08/26/10-things-you-should-know-about-tokens/"/>
    <updated>2014-08-26T09:58:11+08:00</updated>
    <id>http://gbammc.github.io/blog/2014/08/26/10-things-you-should-know-about-tokens</id>
    <content type="html"><![CDATA[<p>原文是一篇很好的讲述 Token 在 Web 应用中使用的<a href="https://auth0.com/blog/2014/01/27/ten-things-you-should-know-about-tokens-and-cookies/#token-storage">文章</a>，而这是我和 <a href="http://www.specyci.com/">Special</a> 合作翻译的译文。</p>

<h1>1. Token 应该被保存起来（放到 local / session stograge 或者 cookies）</h1>

<p>  在单页应用程序中，有些用户刷新浏览器后会带来一些跟 token 相关的问题。而解决方法很简单：你应该把 token 保存到起来：<a href="https://github.com/auth0/angular-token-auth/blob/master/auth.client.js#L31">放到 session storage, local storage 或者是客户端的 cookie 里</a>。而浏览器不支持 session storage 时都应该转存到 cookies 里。</p>

<p>  如果你想“我把 token 保存到 cookie ，不就跟以前没有任何分别？”。可是在这种情况下你只是把 cookie 当作一个储存机制，而不是一种<a href="http://sitr.us/2011/08/26/cookies-are-bad-for-you.html">验证机制</a>。（比如说，这个 cookie 不会被 Web 框架用于用户验证，所以没有 XSRF 攻击的危险）。</p>

<!-- more -->


<h1>2. Tokens 除了像 cookie 一样有有效期，而且你可以有更多的操作方法</h1>

<p>  Tokens 应该有一个有效期（在 <a href="http://tools.ietf.org/html/draft-ietf-oauth-json-web-token-15#section-4.1.4">JSON Web Tokens</a> 中是作为 <code>exp</code> 属性），否则其他人只要登录过一次就可以永远地通过 API 的验证。Cookies 基于同样的理由也有一个有效期。</p>

<p>  在 Cookies 的使用中，有不同的选项可以控制 cookie 的生命周期：</p>

<pre><code>1. cookies 可以在浏览器关闭后删除（session cookies）；

2. 另外你可以实现服务器端的检查（通常由你使用的 Web 框架完成），还有也可以实现绝对有效期或弹性有效期（sliding window expiration）；

3. Cookies 可以带有有效期地保存起来（浏览器关闭后也不删除）。
</code></pre>

<p>  而在 tokens 的使用中，一旦 token 过期，只需要重新获取一个。你可以使用一个接口去刷新 token：</p>

<pre><code>1. 让旧的 token 失效；

2. 检查这个用户是不是还存在，权限是否被取消或者任何对你的程序来说是有必要的；

3. 得到一个更新了有效期的 token。
</code></pre>

<p>  你甚至可以把 token 原来的发布时间也保存起来，并且强制在两星期后重新登录什么的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">app</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="s1">&#39;/refresh_token&#39;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// verify the existing token</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">profile</span> <span class="o">=</span> <span class="nx">jwt</span><span class="p">.</span><span class="nx">verify</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">token</span><span class="p">,</span> <span class="nx">secret</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// if more than 14 days old, force login</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="nx">profile</span><span class="p">.</span><span class="nx">original_iat</span> <span class="o">-</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">14</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// iat == issued at</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">res</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="mi">401</span><span class="p">);</span> <span class="c1">// re-logging</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// check if the user still exists or if authorization hasn&#39;t been revoked</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">valid</span><span class="p">)</span> <span class="k">return</span> <span class="nx">res</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="mi">401</span><span class="p">);</span> <span class="c1">// re-logging</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// issue a new token</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">refreshed_token</span> <span class="o">=</span> <span class="nx">jwt</span><span class="p">.</span><span class="nx">sign</span><span class="p">(</span><span class="nx">profile</span><span class="p">,</span> <span class="nx">secret</span><span class="p">,</span> <span class="p">{</span> <span class="nx">expiresInMinutes</span><span class="o">:</span> <span class="mi">60</span><span class="o">*</span><span class="mi">5</span> <span class="p">});</span>
</span><span class='line'>  <span class="nx">res</span><span class="p">.</span><span class="nx">json</span><span class="p">({</span> <span class="nx">token</span><span class="o">:</span> <span class="nx">refreshed_token</span> <span class="p">});</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>  如果你需要撤回 tokens（当 token 的生存期比较长的时候这很有必要）那么你需要一个 token 的生成管理器去作检查。</p>

<h1>3. Local / session storage 不会跨域工作，请使用一个标记 cookie</h1>

<p>  如果你设置一个 cookie 的域名为 <code>.yourdomain.com</code> 它将可以被 <code>youdomain.com</code> 和 <code>app.yourdomain.com</code> 获取，这样用户登录并且转到 <code>app.yourdomain.com</code> 后也能很容易地从主域名找回这个 cookie（假如你的是电商网站）。</p>

<p>  而另一方面，保存在 local / session storage 的 tokens，就不能从不同的域名中读取（甚至是子域名也不行）。那你能怎么做？</p>

<p>  一个可能的选择是，当用户通过 <code>app.yourdomain.com</code> 上面的验证时你生成一个 token 并且作为一个 cookie 保存到 <code>.yourdomain.com</code></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">$</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="s1">&#39;/authenticate, function() {</span>
</span><span class='line'><span class="s1">  // store token on local/session storage or cookie</span>
</span><span class='line'><span class="s1">    ....</span>
</span><span class='line'>
</span><span class='line'><span class="s1">  // create a cookie signaling that user is logged in</span>
</span><span class='line'><span class="s1">  $.cookie(&#39;</span><span class="nx">loggedin</span><span class="s1">&#39;, profile.name, &#39;</span><span class="p">.</span><span class="nx">yourdomain</span><span class="p">.</span><span class="nx">com</span><span class="err">&#39;</span><span class="p">);</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>  然后，在 <code>youromdain.com</code> 中你可以检查这个 cookie 是不是已经存在了，并且如果存在的话就转到 <code>app.youromdain.com</code>去。从这以后，这个 token 将会对程序的子域名以及之后通常的流程都有效（直到这个 token 超过有效期）。</p>

<p>  不过这将会导致 cookie 存在但 token 被删除了或其他意外情况的发生。在这种情况下，用户将不得不重新登录。但重要的是，像我们之前说的，我们不会这个用 cookie 作为验证方法，只是作为一个存储机制去支持存储信息在不同的域名中。</p>

<h1>4. 每个 CORS（跨域资源共享）请求都会带上预请求（Preflight request）</h1>

<p>  有些人指出 Authorization header 不是一个<a href="http://www.w3.org/TR/cors/">simple header</a>，因此对于一个特定的 URLs 的所有请求都会带上一个预请求。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">OPTIONS</span> <span class="nx">https</span><span class="o">:</span><span class="c1">//api.foo.com/bar</span>
</span><span class='line'><span class="nx">GET</span> <span class="nx">https</span><span class="o">:</span><span class="c1">//api.foo.com/bar</span>
</span><span class='line'>   <span class="nx">Authorization</span><span class="o">:</span> <span class="nx">Bearer</span> <span class="p">....</span>
</span><span class='line'>
</span><span class='line'><span class="nx">OPTIONS</span> <span class="nx">https</span><span class="o">:</span><span class="c1">//api.foo.com/bar2</span>
</span><span class='line'><span class="nx">GET</span> <span class="nx">https</span><span class="o">:</span><span class="c1">//api.foo.com/bar2</span>
</span><span class='line'>   <span class="nx">Authorization</span><span class="o">:</span> <span class="nx">Bearer</span> <span class="p">....</span>
</span><span class='line'>
</span><span class='line'><span class="nx">GET</span> <span class="nx">https</span><span class="o">:</span><span class="c1">//api.foo.com/bar</span>
</span><span class='line'>   <span class="nx">Authorization</span><span class="o">:</span> <span class="nx">Bearer</span> <span class="p">....</span>
</span></code></pre></td></tr></table></div></figure>


<p>  但这只会发生在你发送 <code>Content-Type: application/json</code> 时。不过这说明已经出现在绝大多数的程序中了。</p>

<p>  一个小小的警告，the <code>OPTIONS</code> 请求不会带有 Authorization header 自身，所以你的网络框架应该支持区别对待 <code>OPTISON</code> 和后来的请求。（微软的 IIS 因为某些原因好像会有问题）。</p>

<h1>5. 当你需要流传送某些东西，请用 token 去获取一个已签名的请求。</h1>

<p>  当使用 cookies 时，你可以很容易开始一个文件的下载或流传送内容。然而，在 tokens 的使用中，请求是通过 XHR 完成的，你不能依赖于它。而解决方法应该是像 AWS 那样通过生成一个签名了的请求，例如，Hawk Bewits 是一个很好的框架去启用它：</p>

<p>  <strong>Request:</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">POST</span> <span class="o">/</span><span class="nx">download</span><span class="o">-</span><span class="nx">file</span><span class="o">/</span><span class="mi">123</span>
</span><span class='line'><span class="nx">Authorization</span><span class="o">:</span> <span class="nx">Bearer</span><span class="p">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>  <strong>Response:</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">ticket</span><span class="o">=</span><span class="nx">lahdoiasdhoiwdowijaksjdoaisdjoasidja</span>
</span></code></pre></td></tr></table></div></figure>


<p>  这个 ticket 是无状态并且是基于 URL 的：host + path + query + headers + timestamp + HMAC，并且有一个有效期。所以它可以用于像只能在5分钟内去下载一个文件。</p>

<p>  你然后可以转到 <code>/download-file/123? ticket=lahdoiasdhoiwdowijaksjdoaisdjoasidja</code> 中去。服务器就会检查这个 ticket 是不是有效然后像正常一样开始下一步的服务。</p>

<h1>6. <a href="http://baike.baidu.com/view/50325.htm">XSS</a> 比 <a href="http://baike.baidu.com/view/1609487.htm">XSRF</a> 要更容易防范</h1>

<p>  XSS 攻击的原理是，攻击者插入一段可执行的 JavaScripts 脚本，该脚本会读出用户浏览器的 cookies 并将它传输给攻击者，攻击者得到用户的 Cookies 后，即可冒充用户。但是要防范 XSS 也很简单，在写入 cookies 时，将 <code>HttpOnly</code> 设置为 <code>true</code>，客户端 JavaScripts 就无法读取该 cookies 的值，就可以有效防范 XSS 攻击。因为 Tokens 也是储存在本地的 session storage 或者是客户端的 cookies 中，也是会受到 XSS 攻击。所以在使用 tokens 的时候，必须要考虑过期机制，不然攻击者就可以永久持有受害用户帐号。</p>

<p>  相比 XSS，XSRF 的危害性更大，因为大多数 Web 框架都已经内置了 XSS 防范机制（例如在 Ruby on Rails 中，用户的输入在输出的时候都会做<code>转义</code>操作，攻击者插入的脚本就无法执行），对于大部分开发者而言，甚至连 XSRF 都不知道是什么玩意，更别提防范了。XSRF 目前并不是每个 Web 框架都有防范机制，因此开发者更应该留意 XSRF 。</p>

<h1>7. 注意 token 的大小</h1>

<p>  Token 机制在每次请求 API 的时候，都需要带上一个 <code>Authorization</code> 的 Http Header 。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="err">#</span> <span class="nx">Token</span>
</span><span class='line'><span class="nx">GET</span> <span class="o">/</span><span class="nx">foo</span>
</span><span class='line'><span class="nx">Authorization</span><span class="o">:</span> <span class="nx">Bearer</span> <span class="p">...</span><span class="mi">2</span><span class="nx">kb</span> <span class="nx">token</span><span class="p">...</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="err">#</span> <span class="nx">Cookie</span>
</span><span class='line'><span class="nx">GET</span> <span class="o">/</span><span class="nx">foo</span>
</span><span class='line'><span class="nx">connect</span><span class="p">.</span><span class="nx">sid</span><span class="o">:</span> <span class="p">...</span><span class="mi">20</span> <span class="nx">bytes</span> <span class="nx">cookie</span><span class="p">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>  Token 的大小其实由你储存在 token 中的信息量所决定，例如可能有 <code>nickname</code>，<code>openid</code> 等开发者另外加上的信息。</p>

<p>  但是 session cookies 机制只需要一个字串作为用户标识即可（例如 PHP 的 PHPSESSIONID），其中关于用户的信息都会直接储存到服务端的数据库中，当用户请求时才从数据库中捞出来用。</p>

<p>  当然 Token 机制也可以仿照 session cookies 机制这么做了，也是个有效控制 token 大小的方法。</p>

<p>  Token 中只保留关键的几条身份标识信息，其余都放到数据库里面了，权限控制的时候再捞出。这样做的好处是，开发者可以完全掌控 token，因为关键信息都已经是你代码和数据库中的一部分了，想怎么弄都可以了。</p>

<p>  举个例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">GET</span> <span class="o">/</span><span class="nx">foo</span>
</span><span class='line'><span class="nx">Authorization</span><span class="o">:</span> <span class="nx">Bearer</span> <span class="err">……</span><span class="mi">500</span> <span class="nx">bytes</span> <span class="nx">token</span><span class="err">…</span><span class="p">.</span>
</span><span class='line'><span class="nx">Then</span> <span class="nx">on</span> <span class="nx">the</span> <span class="nx">server</span><span class="o">:</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="s1">&#39;/api&#39;</span><span class="p">,</span>
</span><span class='line'>  <span class="c1">// 首先检查 token；</span>
</span><span class='line'>  <span class="nx">expressJwt</span><span class="p">({</span><span class="nx">secret</span><span class="o">:</span> <span class="nx">secret</span><span class="p">}),</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 然后再从数据库中捞出用户信息。</span>
</span><span class='line'>  <span class="kd">function</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">,</span> <span class="nx">next</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">req</span><span class="p">.</span><span class="nx">user</span><span class="p">.</span><span class="nx">extra_data</span> <span class="o">=</span> <span class="nx">get_from_db</span><span class="p">();</span>
</span><span class='line'>    <span class="nx">next</span><span class="p">();</span>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>  另外值得一提的是，你也可以把东西都丢 Cookies 里面（而不是只丢个身份标识字串）。只要确保资料经过了严格的加密，攻击者无法利用，现在有些 Web 框架已经有类似机制，例如 Nodejs 的这个插件 <a href="https://github.com/mozilla/node-client-sessions">mozilla/node-client-sessions</a>。</p>

<h1>8. 有需要的话，要加密并且签名 token</h1>

<p>  虽然 TLS/SSL 机制可以隔绝大多数中间人攻击，但是如果 token 中带有了用户的敏感信息，开发者也应该要加密这些信息。</p>

<p>  使用 JWT（文中第 9 点） 可以加密 token，但是由于目前大多数 Web 框架还未支持 JWT，所以可以使用 AES-CBC 算法加密 token。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">app</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="s1">&#39;/authenticate&#39;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// 校验用户；</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 加密 token；</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">encrypted</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">token</span><span class="o">:</span> <span class="nx">encryptAesSha256</span><span class="p">(</span><span class="s1">&#39;shhhh&#39;</span><span class="p">,</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">profile</span><span class="p">))</span> <span class="p">};</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 给加密后的 token 签名；</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">token</span> <span class="o">=</span> <span class="nx">jwt</span><span class="p">.</span><span class="nx">sign</span><span class="p">(</span><span class="nx">encrypted</span><span class="p">,</span> <span class="nx">secret</span><span class="p">,</span> <span class="p">{</span> <span class="nx">expiresInMinutes</span><span class="o">:</span> <span class="mi">60</span><span class="o">*</span><span class="mi">5</span> <span class="p">});</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">res</span><span class="p">.</span><span class="nx">json</span><span class="p">({</span> <span class="nx">token</span><span class="o">:</span> <span class="nx">token</span> <span class="p">});</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">function</span> <span class="nx">encryptAesSha256</span> <span class="p">(</span><span class="nx">password</span><span class="p">,</span> <span class="nx">textToEncrypt</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">cipher</span> <span class="o">=</span> <span class="nx">crypto</span><span class="p">.</span><span class="nx">createCipher</span><span class="p">(</span><span class="s1">&#39;aes-256-cbc&#39;</span><span class="p">,</span> <span class="nx">password</span><span class="p">);</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">crypted</span> <span class="o">=</span> <span class="nx">cipher</span><span class="p">.</span><span class="nx">update</span><span class="p">(</span><span class="nx">textToEncrypt</span><span class="p">,</span> <span class="s1">&#39;utf8&#39;</span><span class="p">,</span> <span class="s1">&#39;hex&#39;</span><span class="p">);</span>
</span><span class='line'>  <span class="nx">crypted</span> <span class="o">+=</span> <span class="nx">cipher</span><span class="p">.</span><span class="kr">final</span><span class="p">(</span><span class="s1">&#39;hex&#39;</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="nx">crypted</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 上面就是 encrypt-then-MAC （加密后签名）做法。 </span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>  当然你也可以用文中的第 7 点，直接将敏感信息丢数据库中。</p>

<h1>9. 将 JSON Web Tokens 应用到 OAuth 2</h1>

<p>  OAuth 2 是一个解决身份验证的授权协议，并且广泛地使用了 token 。</p>

<p>  用户通过 OAuth 2 协议授权第三方应用权限，然后服务器返回一个 <code>access_token</code> 给第三方应用，通常也带有 <code>scope</code> 参数，第三方应用通过带上 <code>access_token</code> 请求服务器，可以在授权范围（scope）内调用 API。</p>

<p>  一般来说，类似这种 token 是不透明的，就是核心数据都储存以 hash-table 结果储存在服务器中，客户端只持有一个<code>令牌</code>（access_token），任何人都可以用这个令牌在授权范围（scope）内调用服务器端的 API。</p>

<p>  Signed tokens（例如 <a href="http://jwt.io">JWT</a>)）和这种形式的 token 最主要的区别是，JWT 是无状态的，它不储存在服务端 hash-table 中，服务端中不保留 JWT 请求的相关信息，JWT 会把授权信息和 API 调用返回都丢一起返回给客户端。</p>

<p>  JWT 通常以 Base64 + AES 方式编码传输。OAuth 2 协议也支持 JWT，因为 OAuth 2 并未限制 access_token 数据格式，你可以将 JWT 应用在 OAuth 2 上。</p>

<h1>10. Tokens 不是万能的解决方法，得根据你的需求自行采用</h1>

<p>  这些年来，我们帮助过不少大公司实现了他们的以 Token 为基础的验证授权架构。曾经有一家 10k + 员工，有着大量数据的公司，他们想实现一个中央权限管理系统，其中有一个需要是某个员工只能读取某个国家某个医院某个床位的<code>id</code>和<code>name</code>字段数据，想想这样的细粒度的权限管理是多么难实现，无论是技术上还是行政上。</p>

<p>  当然采用 tokens 与否，得看大家的具体需求，但是，要忠告大家的是，不要什么内容都写到 tokens 了，加之前想想有没有这个必要。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift官方文档阅读笔记]]></title>
    <link href="http://gbammc.github.io/blog/2014/06/03/swift-101/"/>
    <updated>2014-06-03T23:11:37+08:00</updated>
    <id>http://gbammc.github.io/blog/2014/06/03/swift-101</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>在WWDC14前曾收听了<code>IT公论</code>第57期节目，该期节目主要讨论了 Objective-C 作为目前最流行 App 的开发语言是否到了烈士暮年的阶段，并且最后预言了苹果将会为此而开发新的编程语言。但万万没想到就是在今年，苹果真的推出了自家研发的<code>Swift</code>!。</p>

<p>据资料显示，Swift开始于2010年7月左右，最初只有很少人知道这个项目的存在。2011后期新加入几位。2013成为Developer Tools的重点。吸收了来自Objective-C, Rust, Haskell, Ruby, Python, C#, CLU以及很多其它语言的元素。这里是其中一位开发者的<a href="http://nondot.org/sabre/">主页</a>。</p>

<!-- more -->


<p>伴随 Swift 推出的还有 <code>Playground</code>，而苹果是这样描述Playground的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>利用Playground，你可以：
</span><span class='line'>
</span><span class='line'>* 设计一个新算法，并可以直接观察它每一步的运行结果
</span><span class='line'>* 在提交到测试套件前，可以验证你的新测试用例
</span><span class='line'>* 尝试新的API来升级你的Swift编程技能</span></code></pre></td></tr></table></div></figure>


<h1>Swift</h1>

<h2>基础部分</h2>

<p>只记录一些需要特别注意的部分</p>

<ul>
<li>文档中提到，Swift会大量使用常量，对于不会改变的值就应该定义为常量。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let definetConstant = "I am constant" // 使用关键字 let 定义一个新的常量</span></code></pre></td></tr></table></div></figure>


<ul>
<li>绝大多数的字符都可以作为常量和变量的名字：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let π = 3.14159
</span><span class='line'>
</span><span class='line'>let 你好 = "你好世界"
</span><span class='line'>
</span><span class='line'>let 🐶🐮 = "dogcow”
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>如果不得已需要用Swift保留的关键字作为变量或常量的名字，那么应该在前后加上<code>`</code>：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var `break` = 1
</span><span class='line'>
</span><span class='line'>var `return` = 2
</span><span class='line'>
</span><span class='line'>var result = `break` + `return`</span></code></pre></td></tr></table></div></figure>


<ul>
<li>和<code>NSInteger</code>一样，Swift中的<code>Int</code>也是根据当前系统平台而有不同的大小：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>32位系统中，Int的大小为Int32
</span><span class='line'>64位系统中，Int的大小为Int64</span></code></pre></td></tr></table></div></figure>


<h2>基本操作符</h2>

<ul>
<li>与 C 和 Objective-C 不同，Swift的赋值操作符不会有返回值，以下两个例子都会报错：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>if x = y {
</span><span class='line'>    // 报错
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>var a = b = c = 0 // 报错
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><p>默认情况下，普通的四则运算符都不会允许溢出的发生，但可以使用允许溢出的操作符</p></li>
<li><p><code>%</code>求余操作符遵循以下运算求解：</p></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// remainder = a % b
</span><span class='line'>a = (b × some multiplier) + remainder
</span><span class='line'>
</span><span class='line'>// b的符号将会被忽略
</span><span class='line'>-9 % 4    // equals -1
</span><span class='line'>-9 % -4    // equals -1</span></code></pre></td></tr></table></div></figure>


<ul>
<li><code>%</code>对浮点数同样有效：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>8 % 2.5    // equals 0.5</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[django + pip + virtualenv ＋ postgres]]></title>
    <link href="http://gbammc.github.io/blog/2014/04/22/django-101/"/>
    <updated>2014-04-22T23:40:58+08:00</updated>
    <id>http://gbammc.github.io/blog/2014/04/22/django-101</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>最近兴趣所致，想学习利用 Django 编写一个项目，无奈之前不太懂 python，在机子乱搞一通后发现系统的环境都被玩坏了，GoAgentX 都跑不了..不过经过一番折腾后总算是走上正轨，所以顺便总结一下吧。</p>

<!-- more -->


<h1>安装 python，pip 和 easy_install</h1>

<p>虽然 OS X 已经自带有多个版本的 python，不过还是推荐使用 homebrew 安装一个，因为 homebrew 还会自动帮我们安装 pip 和 easy_install 这两个包管理工具，更详细的关于 python 包管理工具资料请戳<a href="http://jiayanjujyj.iteye.com/blog/1409819">这里</a>：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>brew install python --universal --framework</span></code></pre></td></tr></table></div></figure>


<p>然后我们需要检查是否有 <code>/usr/local/share/python</code> 这个文件夹，如果不存在的话需要建立一个软链接，例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ln -s /usr/local/Cellar/python/2.7.6/Frameworks/Python.framework/Versions/2.7/bin/ /usr/local/share/python</span></code></pre></td></tr></table></div></figure>


<p>上面的<code>2.7</code>是当前 python 的版本号，按需替换即可。</p>

<hr />

<h1>安装 virtualenv 和 virtualenvwrapper</h1>

<p>virtualenv <a href="http://virtualenv.org/">官网</a> 是这样描述自己的：</p>

<blockquote><p>virtualenv要解决的根本问题是库的版本和依赖，以及权限问题。假设你有一个程序，需要LibFoo的版本1，而另一个程序需要版本2，如何同时使用两个应用程序呢？如果将所有的库都安装在 /usr/lib/python2.7/site-packages（或者你的系统的标准包安装路径），非常容易出现将不该升级的库升级的问题。</p>

<p>另外，在一台共享的机器上，如果没有全局的 site-packages 目录的权限（例如一个共享的主机），如何安装Python库呢？</p>

<p>在这些情况下，就是该用到virtualenv的地方。它能够创建一个自己的安装目录，形成一个独立的环境，不会影响其他的virtualenv环境，甚至可以不受全局的site-packages当中安装的包的影响。</p></blockquote>

<p>通过为每个项目创建虚拟环境，在每个虚拟环境中安装需要的第三方包版本，那么不同的项目就可以独立的使用一个  django 环境。virtualenvwrapper 则为 virtualenv 提供了一些便利的命令行上的封装。</p>

<p>首先在我们的 .bashrc 或( .zshrc )加上:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># Before other PATHs...
</span><span class='line'>PATH=${PATH}:/usr/local/share/python
</span><span class='line'>
</span><span class='line'># Python
</span><span class='line'>export WORKON_HOME=$HOME/.virtualenvs
</span><span class='line'>export VIRTUALENVWRAPPER_PYTHON=/usr/local/bin/python2.7
</span><span class='line'>export VIRTUALENVWRAPPER_VIRTUALENV_ARGS='--no-site-packages'
</span><span class='line'>export PIP_VIRTUALENV_BASE=$WORKON_HOME
</span><span class='line'>export PIP_RESPECT_VIRTUALENV=true
</span><span class='line'>if [[ -r /usr/local/share/python/virtualenvwrapper.sh ]]; then
</span><span class='line'>    source /usr/local/share/python/virtualenvwrapper.sh
</span><span class='line'>else
</span><span class='line'>    echo "WARNING: Can't find virtualenvwrapper.sh"
</span><span class='line'>fi
</span><span class='line'>
</span><span class='line'># 
</span></code></pre></td></tr></table></div></figure>


<p>然后安装：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ pip install virtualenv 
</span><span class='line'>$ pip install virtualenvwrapper</span></code></pre></td></tr></table></div></figure>


<p>virtualenvwrapper 的用法当然还是看<a href="http://virtualenvwrapper.readthedocs.org/en/latest/">文档</a>最靠谱啦。</p>

<hr />

<h1>安装 django</h1>

<p>主角来了，首先<code>cd</code>到项目创建目录下，然后用 virtualenv 为我们的项目创建一个虚拟环境：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>mkvirtualenv env1</span></code></pre></td></tr></table></div></figure>


<p>接着就是安装 django：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pip install django</span></code></pre></td></tr></table></div></figure>


<p>Finished，这就完成啦，实在是太简单了 :]</p>

<hr />

<h1>带上 postgres</h1>

<p>最后，因为公司维护的要求，顺便就上 postgres了 (<a href="http://www.zhihu.com/question/20010554">PostgreSQL 与 MySQL 相比，优势何在？</a>) ，为了 django 能和 postgres 连接，先装<code>psycopg2</code>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pip install psycopg2</span></code></pre></td></tr></table></div></figure>


<p>然后就修改应用中的<code>settings.py</code>配置：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>DATABASES = {
</span><span class='line'>    'default': {
</span><span class='line'>        'ENGINE': 'django.db.backends.postgresql_psycopg2', 
</span><span class='line'>        'NAME': 'test',    
</span><span class='line'>        'USER': 'user',                  # Not used with sqlite3.
</span><span class='line'>        'PASSWORD': 'pwd',               # Not used with sqlite3.
</span><span class='line'>        'HOST': '',                      # Set to empty string for localhost. Not used with sqlite3.
</span><span class='line'>        'PORT': '5432',                  # Set to empty string for default. Not used with sqlite3.
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<p>最后同步一下项目的数据库：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>python manage.py syncdb</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Solr和Sunspot全文索引使用方法和一般问题解决办法]]></title>
    <link href="http://gbammc.github.io/blog/2014/02/16/using-solr-and-sunspot-in-ruby/"/>
    <updated>2014-02-16T01:20:00+08:00</updated>
    <id>http://gbammc.github.io/blog/2014/02/16/using-solr-and-sunspot-in-ruby</id>
    <content type="html"><![CDATA[<p>最近做的一个项目有全文搜索的需求，而Solr经过多年的发展，已经有完善的文档和社区支持，所以我就尝试用它作为搜索引擎。因为使用过程中遇到了几个坑，因此想记录下来，同时也希望这篇文章能帮到遇上同样问题的人:]</p>

<!-- more -->


<p> Solr &amp;&amp; Sunspot
Solr是一个开源的搜索服务器，Solr使用Java语言开发，主要基于HTTP和Apache Lucene而实现。定制Solr索引的实现方法很简单，用POST方法向Solr服务器发送一个描述所有Field及其内容的XML文档就可以了。定制搜索的时候只需要发送HTTP的GET请求即可。</p>

<p>而在Ruby下使用Sunspot这个Gem就足够了，因为里面已经封装了Solr的底层操作，提供简单而强大的索引和查找对象功能，同时也支持各种ORM。</p>

<h1>安装</h1>

<p>首先，如上所述，要运行Solr，你要先有Java运行环境，还没安装的话就请移步到Google搜索安装方法，这里就不多说了。</p>

<p>毫无疑问，要在Gemfile中添加：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">gem</span> <span class="s1">&#39;sunspot_rails&#39;</span>
</span><span class='line'><span class="n">gem</span> <span class="s1">&#39;sunspot_solr&#39;</span> <span class="c1"># optional pre-packaged Solr distribution for use in development</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后毫无疑问是Bundle：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">bundle</span> <span class="n">install</span>
</span></code></pre></td></tr></table></div></figure>


<p>接着生成配置文件<code>config/sunspot.yml</code>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">rails</span> <span class="n">generate</span> <span class="n">sunspot_rails</span><span class="ss">:install</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果安装<code>sunspot_solr</code>了，那么就运行它：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">bundle</span> <span class="nb">exec</span> <span class="n">rake</span> <span class="ss">sunspot</span><span class="p">:</span><span class="ss">solr</span><span class="p">:</span><span class="n">start</span>
</span></code></pre></td></tr></table></div></figure>


<p>至此，Solr就应该能跑起来了。</p>

<p>至于要关闭它，也只要把<code>start</code>换成<code>stop</code>即可：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">bundle</span> <span class="nb">exec</span> <span class="n">rake</span> <span class="ss">sunspot</span><span class="p">:</span><span class="ss">solr</span><span class="p">:</span><span class="n">start</span>
</span></code></pre></td></tr></table></div></figure>


<h1>对象设置</h1>

<p>对象设置也和安装一样简单，只要在model里添加一个<code>searchable</code>的block指明需要索引的字段和查询范围即可，例如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">School</span> <span class="o">&lt;</span> <span class="ss">ActiveRecord</span><span class="p">:</span><span class="ss">:Base</span>
</span><span class='line'>  <span class="n">searchable</span> <span class="k">do</span>
</span><span class='line'>    <span class="n">text</span> <span class="ss">:name</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">time</span> <span class="ss">:found_at</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">attr_accessible</span> <span class="ss">:name</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>那么被<code>text</code>声明的字段就会作为全文索引，至于<code>time</code>或其它Sunspot可以使用的类型(boolean, integer, string等)就会作为查询范围时使用。</p>

<h1>对象查找</h1>

<p>继续用上面的model作为例子，当我们需要查找校名，那么可以设定这样一个方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">search_school</span><span class="p">(</span><span class="n">school_name</span><span class="p">)</span>
</span><span class='line'>  <span class="vi">@schools</span> <span class="o">=</span> <span class="no">School</span><span class="o">.</span><span class="n">search</span> <span class="k">do</span>
</span><span class='line'>    <span class="n">fulltext</span> <span class="n">school_name</span>
</span><span class='line'>  <span class="k">end</span><span class="o">.</span><span class="n">results</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">return</span> <span class="vi">@schools</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>很好，这就完成啦！<code>fulltext</code>后面跟着的就是搜索的关键词，查询的结果通过<code>#results</code>方法取出。</p>

<h1>Reindex</h1>

<p>当我们在School中添加或删除记录时，sunpost自动就会帮我们重新reindex，但如果我们需要添加新的字段或不得不需要手动reindex时，可以使用如下指令：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">rake</span> <span class="ss">sunspot</span><span class="p">:</span><span class="n">redinex</span>
</span></code></pre></td></tr></table></div></figure>


<h1>几个开发中遇到的问题</h1>

<ul>
<li><h2>中文搜索</h2></li>
</ul>


<p>如果想让Solr支持中文也十分简单，只要将设定中的tokenizer替换成你想使用的分词系统即可，而Solr内建简单的CJK分词系统，只要将<code>solr/conf/schema.xml</code>大概第64行换成：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="o">&lt;</span><span class="n">tokenizer</span> <span class="n">class</span><span class="o">=</span><span class="s2">&quot;solr.CJKTokenizerFactory&quot;</span><span class="o">/&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后重启Solr并且reindex应该就能使用了。</p>

<ul>
<li><h2>undefined method `results&#8217; for #&lt;MetaSearch::Searches &hellip;</h2></li>
</ul>


<p>如果出现以下的问题，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">undefined</span> <span class="nb">method</span> <span class="sb">`results&#39; for #&lt;MetaSearch::Searches::School:0x007fda483ef128&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>那可能是因为你同时安装了MetaSearch或像ActiveAdmin这些用了MetaSearch的Gem，而和Solr发生了冲突，解决办法是把搜索方法改成这样：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">search_school</span><span class="p">(</span><span class="n">school_name</span><span class="p">)</span>
</span><span class='line'>  <span class="vi">@schools</span> <span class="o">=</span> <span class="no">School</span><span class="o">.</span><span class="n">solr_search</span> <span class="k">do</span>
</span><span class='line'>    <span class="n">fulltext</span> <span class="n">school_name</span>
</span><span class='line'>  <span class="k">end</span><span class="o">.</span><span class="n">results</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">return</span> <span class="vi">@schools</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>或这样：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">search_school</span><span class="p">(</span><span class="n">school_name</span><span class="p">)</span>
</span><span class='line'>  <span class="vi">@schools</span> <span class="o">=</span> <span class="no">Sunspot</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="no">School</span><span class="p">)</span> <span class="k">do</span>
</span><span class='line'>    <span class="n">fulltext</span> <span class="n">school_name</span>
</span><span class='line'>  <span class="k">end</span><span class="o">.</span><span class="n">results</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">return</span> <span class="vi">@schools</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><h2>Request Data: &ldquo;&lt;?xml version=&#34;1.0\&rdquo; encoding=\&ldquo;UTF-8\&rdquo;?>type:Match&#8221; &hellip;</h2></li>
</ul>


<p>而如果在production中出现404 xxx</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">rake</span> <span class="ss">sunspot</span><span class="p">:</span><span class="n">reindex</span>
</span><span class='line'><span class="n">rake</span> <span class="n">aborted!</span>
</span><span class='line'><span class="ss">RSolr</span><span class="p">:</span><span class="ss">:Error</span><span class="o">::</span><span class="no">Http</span> <span class="o">-</span> <span class="mi">404</span> <span class="no">Not</span> <span class="no">Found</span>
</span><span class='line'><span class="ss">Error</span><span class="p">:</span> <span class="no">Not</span> <span class="no">Found</span>
</span><span class='line'>
</span><span class='line'><span class="no">Request</span> <span class="ss">Data</span><span class="p">:</span> <span class="s2">&quot;&lt;?xml version=</span><span class="se">\&quot;</span><span class="s2">1.0</span><span class="se">\&quot;</span><span class="s2"> encoding=</span><span class="se">\&quot;</span><span class="s2">UTF-8</span><span class="se">\&quot;</span><span class="s2">?&gt;type:Match&quot;</span> <span class="o">.</span><span class="n">.</span><span class="o">.</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以先尝试修改<code>config/sunspot.yml</code>中的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="ss">production</span><span class="p">:</span>
</span><span class='line'>   <span class="ss">solr</span><span class="p">:</span>
</span><span class='line'><span class="o">.</span><span class="n">.</span><span class="o">.</span>
</span><span class='line'>      <span class="ss">path</span><span class="p">:</span> <span class="sr">/solr/</span><span class="n">production</span>
</span></code></pre></td></tr></table></div></figure>


<p>改为：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'> <span class="ss">production</span><span class="p">:</span>
</span><span class='line'>   <span class="ss">solr</span><span class="p">:</span>
</span><span class='line'><span class="o">.</span><span class="n">.</span><span class="o">.</span>
</span><span class='line'>      <span class="ss">path</span><span class="p">:</span> <span class="sr">/solr/</span><span class="n">default</span>
</span></code></pre></td></tr></table></div></figure>


<h1>相关链接</h1>

<ul>
<li><p><a href="https://github.com/sunspot/sunspot">Sunspot in Github</a></p></li>
<li><p><a href="http://wwangcg.iteye.com/blog/1327670">Lucene的分词原理与分词系统</a></p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[译]我是怎样学习测试我的Rails应用的-Part1:开端]]></title>
    <link href="http://gbammc.github.io/blog/2014/01/20/wo-shi-zen-yang-xue-xi-ce-shi-wo-de-railsying-yong-de-part1-kai-duan/"/>
    <updated>2014-01-20T10:34:00+08:00</updated>
    <id>http://gbammc.github.io/blog/2014/01/20/wo-shi-zen-yang-xue-xi-ce-shi-wo-de-railsying-yong-de-part1-kai-duan</id>
    <content type="html"><![CDATA[<p>最近在学习Rails的开发过程中深感TDD和BDD的好处，开发效率远比没有使用测试的时候高。例如：当项目需求突然有变时，在修改部分代码后，为了确保程序还能如常运行，就不得不再手动测试各个页面。而且正如卷福所说：人总是会犯错的，所以还不能保证每次都测试出所有错误。但使用TDD和BDD后，只要保证有足够多的测试样例来覆盖程序中各个部分，那么每次修改后都只要轻轻一运行测试样例，那么所有bug都将无处遁形。</p>

<p><a href="http://everydayrails.com/">原作者</a>通过一系列的文章深入浅出地介绍了自己是怎样测试自己的程序的，个人打算将其翻译出来，希望藉此提升自己的能力的同时，能帮助更多的人使用TDD和BDD进行开发。而这是该系列的第一篇(<a href="http://everydayrails.com/2012/03/12/testing-series-intro.html">How I learned to test my Rails applications, Part 1: Introduction</a>)。不过本人翻译过的文章不多，如有错误，诚挚希望进行指教:]</p>

<!-- more -->


<hr />

<p>Ruby On Rails和自动化测试，两者可谓齐头并进。Rails带有内建的测试框架，但如果这不是你的菜的话还能替换成自己喜欢的。所以，测试对Rails是非常重要的 &mdash; 不过有很多Rails开发者可能没有测试他们的项目，或者只是充其量地添加一些简单的模型验证。</p>

<p>可能对于开发Ruby或Web框架的人来说这是一个很新的概念。可能是觉得这会增加额外的工作。或者这会让他感到时间紧迫 &mdash; 花时间在写测试上会影相完成新需求的进度。或者是在浏览器上点击链接的测试习惯很难改变。</p>

<p>我曾经也是如此，我从1995年开始开发Web程序，但通常就像开发小型项目的独立开发者那样。除了小时候学过一下BASIC，在大学学过一些C++，还有在毕业后我的第二份工作中浪费了一个星期的Java，我从来没有好好地学习过软件开发。事实上，直到2005年，当我受够丑陋的意大利面条式的Php代码后，我发现一种更好的Web程序开发方法。</p>

<p>我以前曾关注过Ruby，不过直到Rails流行前都没有深度使用过它。因为这需要学习很多东西 &mdash; 新语言，新架构和更面向对象的方法(a more object-oriented approach)。不过虽然有这些新挑战，我还是能够在以前缺少框架努力的碎片时间下创造出复杂的程序。我知道我被吸引住了。</p>

<p>也就是说，早期Rails的书或指引都是更关注在开发速度上(15分钟搭建一个博客!)而不是更好的测试实践上。就算包括测试的讲解，它通常都是保留在最后一章。新运行于Rails的项目开始注意到这个缺陷，也已经有不少书的内容都有关于测试的章节，不过还缺少一套可行的测试方法。我写这个系列的目的，就是想向您介绍对我的方法。</p>

<h1>谁应该读这些文章</h1>

<p>如果Rails是你第一个使用的Web程序开发框架，而且你以前的编程经验很少涉及到测试，那么这系列会很好地帮助你开始了解测试。如果你真的是Rails的菜鸟，你也能在Michael Hartl的《Rails Tutorial》或者 Sam Ruby的《Agile Web Development with Rails》里看到关于测试的部分。这一系列是假设你已经有基本的Rails使用经验之上的。换句话说，这一系列不会教你怎样使用Rails，它也不会提供内置的测试框架介绍 &mdash; 因为我们将要安装一些额外的工具使我们的测试过程更容易理解和管理。</p>

<p>如果你已经用Rails有一段时间了，或者你已经有一两个Rails产品了，但对测试仍然是一个陌生概念的话，这系列就适合你了。我曾经也和你一样，我在这里分享的技巧帮助我提交我的测试覆盖和使我更像一个测试驱动的开发者。我希望这些也能帮到你。</p>

<p>而如果你已经很熟悉Test::Unit或者RSpec，甚至有一个你已经很熟悉的或已经足够覆盖的工作流程，您可以微调你的一些方法来测试您的应用程序 &mdash; 不过说实在的，你可能已经使用自动化测试了而且不需要这些额外的帮助了。像David Chelimsky的《The RSpec Book》或者 Noel Rappin的《Rails Test Prescriptions》这些书对你来说可能更有用。</p>

<h1>我的测试哲学</h1>

<p>讨论正确的方法来测试你的Rails可能会涉及到圣战 &mdash; 虽然不会像Vim和Emacs的争论那样，但仍然不是一个和其它Ruby开发者能开心讨论的话题。是的，虽然有一种正确的方法来做测试，但是也有正确的层次。</p>

<p>冒着在Ruby的TDD和BDD社区中掀起风暴的危险，我的讨论将关注以下几点：</p>

<ul>
<li>测试应该是可靠的</li>
<li>测试应该是易写的</li>
<li>测试应该是易理解的</li>
</ul>


<p>如果你遵循这3步方法，那么对于你的程序可用的测试套件会有很长的路要走 &ndash; 更不用说成为测试驱动开发的忠实实践者了。</p>

<p>是的，有一些东西需要权衡，特别是：</p>

<ul>
<li>我们不注重速度</li>
<li>我们在测试中不关注我们的代码完全DRY</li>
</ul>


<p>最后，最重要的一点是，你将会得到可靠，易理解的测试样例，尽管它们不是很优化，但它们是一个很好的开始。也正是这样，使我免于陷入写大量的程序代码，然后在浏览器上点击&#8221;测试&#8221;，然后希望运行成功的循环中。而且还获得了完全自动化的测试套件的优势和使用测试驱动开发深挖潜在的bug。</p>

<p>准备好了？来就看第二部分吧:<a href="">配置Rails程序来使用RSpec</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[转]ARC深入浅出]]></title>
    <link href="http://gbammc.github.io/blog/2013/12/02/zhuan-arcshen-ru-qian-chu/"/>
    <updated>2013-12-02T00:37:00+08:00</updated>
    <id>http://gbammc.github.io/blog/2013/12/02/zhuan-arcshen-ru-qian-chu</id>
    <content type="html"><![CDATA[<p>ARC可谓iOS开发中一大利器，内存管理的大部份问题都能交由系统自动处理了，不过一些不太明显的小坑也需我们多加注意，不然用户在使用中出现闪退，那用户体验就差多了。最近看了@易飞扬 先生一系列关于ARC的博文，觉得非常详细易懂，可惜需要翻墙才能看到，所以转载到这里，同时对原文内容进行了一些小修改，再次感谢易先生的分享 :P</p>

<!-- more -->


<h1>TL;DR</h1>

<p>内存管理依循下面的基本原则:</p>

<ul>
<li>自己生成的对象，那么即是其持有者</li>
<li>不是自己生成的对象，也可成为其持有者（一个对象可以被多个人持有）</li>
<li>如果不想持有对象的时候，必须释放其所有权</li>
<li>不能释放已不再持有所有权的对象</li>
</ul>


<p>ARC使用准则:</p>

<ul>
<li>不能使用 retain/release/retainCount/autorelease</li>
<li>不能使用 NSAllocateObject/NSDeallocateObject</li>
<li>不能使用 NSZone</li>
<li>不能明示调用dealloc</li>
<li>内存管理相关的函数必须遵循命名规则</li>
<li>使用@autoreleasepool代替NSAutoreleasePool</li>
<li>Objective-C 对象不能作为C语言结构体（struct/union）的成员</li>
<li>[id]与[void*]之间需要明示cast</li>
</ul>


<p>原文地址：</p>

<p><a href="http://www.yifeiyang.net/development-of-the-iphone-simply-1/">iPhone开发之深入浅出 (1) — ARC是什么</a> &mdash;&mdash;&mdash; <a href="#1">本文传送门</a></p>

<p><a href="http://www.yifeiyang.net/development-of-the-iphone-simply-2/">iPhone开发之深入浅出 (2) — ARC之@property使用</a> &mdash;&mdash;&mdash; <a href="#2">本文传送门</a></p>

<p><a href="http://www.yifeiyang.net/development-of-the-iphone-simply-3/">iPhone开发之深入浅出 (3) — ARC之前世今生</a> &mdash;&mdash;&mdash; <a href="#3">本文传送门</a></p>

<p><a href="http://www.yifeiyang.net/development-of-the-iphone-simply-4/">iPhone开发之深入浅出 (4) — ARC之循环参照</a> &mdash;&mdash;&mdash; <a href="#4">本文传送门</a></p>

<p><a href="http://www.yifeiyang.net/development-of-the-iphone-simply-5/">iPhone开发之深入浅出 (5) — ARC之Outlet与弱引用</a> &mdash;&mdash;&mdash; <a href="#5">本文传送门</a></p>

<p><a href="http://www.yifeiyang.net/development-of-the-iphone-simply-6/">iPhone开发之深入浅出 (6) — ARC之对象转型</a> &mdash;&mdash;&mdash; <a href="#6">本文传送门</a></p>

<p><a href="http://www.yifeiyang.net/development-of-the-iphone-simply-7/">iPhone开发之深入浅出 (7) — ARC总结</a> &mdash;&mdash;&mdash; <a href="#7">本文传送门</a></p>

<hr />

<h1><span id="1">ARC是什么</span></h1>

<p>ARC是iOS5推出的新功能，全称叫 ARC(Automatic Reference Counting)。简单地说，就是代码中自动加入了retain/release，原先需要手动添加的用来处理内存管理的引用计数的代码可以自动地由编译器完成了。</p>

<h3>使用ARC的好处</h3>

<ul>
<li>使用ARC后，Objective-C的代码变得简单多了，因为我们不需要担心烦人的内存管理，担心内存泄露了</li>
<li>代码的总量变少了，看上去清爽了不少，也节省了劳动力</li>
<li>代码高速化，由于使用编译器管理引用计数，减少了低效代码的可能性</li>
</ul>


<h3>不好的地方</h3>

<ul>
<li>记住一堆新的ARC规则 — 关键字及特性等需要一定的学习周期；</li>
<li>一些旧的代码，第三方代码使用的时候比较麻烦；修改代码需要工数，要么修改编译开关</li>
</ul>


<p>如果只想对某个.m文件不应用ARC，可以只针对该类文件加上 -fno-objc-arc 编译FLAGS。（另外如果工程并未打开ARC，而要对某个文件应用ARC，可以加上-fobjc-arc编译FLAGS）</p>

<h3>ARC基本规则</h3>

<ul>
<li>retain, release, autorelease, dealloc由编译器自动插入，不能在代码中调用</li>
<li>dealloc虽然可以被重载，但是不能调用[super dealloc]</li>
</ul>


<h3>Objective-C对象</h3>

<p>ObjectiveC中的对象，有强参照(Strong reference)和弱参照(Weak reference)之分，当需要保持其他对象的时候，需要retain以确保对象引用计数加1。对象的持有者(owner)只要存在，那么该对象的强参照就一直存在。</p>

<h5>对象处理的基本规则是</h5>

<ul>
<li>只要对象的持有者存在（对象被强参照），那么就可以使用该对象</li>
<li>对象失去了持有者后，即被释放</li>
</ul>


<h3>强参照 (Strong reference)</h3>

<p><img src="http://gbammc.github.io/images/arc/ARC_outline_strong.JPG"></p>

<p>(s1)</p>

<p>firstName作为”natsu”字符串对象的最初持有者，是该NSString类型对象的Strong reference。</p>

<p>(s2)</p>

<p>这里将firstName代入到aName中，即aName也成为了@”natsu”字符串对象的持有者，对于该对象，aName也是Strong reference。</p>

<p>(s3)</p>

<p>这里，改变firstName的内容。生成新的字符串对象”maki”。这时候firstName成为”maki”的持有者，而@”natsu”的持有者只有aName。每个字符串对象都有各自的持有者，所以它们都在内存中都存在。</p>

<p>(s4)</p>

<p>追加新的变量otherName, 它将成为@”maki”对象的另一个持有者。即NSString类型对象的Strong reference。</p>

<p>(s5)</p>

<p>将otherName代入到aName，这时，aName将成为@”maki”字符串对象的持有者。而对象@”natsu”已经没有持有者了，该对象将被释放。</p>

<h3>弱参照 (Weak reference)</h3>

<p><img src="http://gbammc.github.io/images/arc/ARC_outline_weak.png"></p>

<p>(w1)</p>

<p>与强参照方式同样，firstName作为字符串对象@”natsu”的持有者存在。即是该NSString类型对象的Strong reference。</p>

<p>(w2)</p>

<p>使用关键字__weak，声明弱参照weakName变量，将firstName代入。这时weakName虽然参照@”natsu”，但仍是Weak reference。即weakName虽然能看到@”natsu”，但不是其持有者。</p>

<p>(w3)</p>

<p>firstName指向了新的对象@”maki”，成为其持有者，而对象@”natsu”因为没有了持有者，即被释放。同时weakName变量将被自动代入nil。</p>

<h3>引用关键字</h3>

<p>ARC中关于对象的引用参照，主要有下面几个关键字。使用strong, weak, autoreleasing限定的变量会被隐式初始化为nil。</p>

<h6>__strong</h6>

<p>变量声明缺省都带有__strong关键字，如果变量什么关键字都不写，那么缺省就是强参照。</p>

<h6>__weak</h6>

<p>上面已经看到了，这是弱参照的关键字。该概念是新特性，从 iOS 5/ Mac OS X 10.7 开始导入。由于该类型不影响对象的生命周期，所以如果对象之前就没有持有者，那么会出现刚创建就被释放的问题，比如下面的代码。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">NSString</span> <span class="n">__weak</span> <span class="o">*</span><span class="n">string</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSString</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithFormat:</span><span class="s">@&quot;First Name: %@&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">self</span> <span class="n">firstName</span><span class="p">]];</span>
</span><span class='line'><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;string: %@&quot;</span><span class="p">,</span> <span class="n">string</span><span class="p">);</span> <span class="c1">//此时 string为空</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果编译设定OS版本 Deployment Target 设定为这比这低的版本，那么编译时将报错(The current deployment target does not support automated __weak references)，这个时候，我们可以使用下面的__unsafe_unretained。</p>

<p>弱参照还有一个特征，即当参数对象失去所有者之后，变量会被自动付上nil (Zeroing)。</p>

<h6>__unsafe_unretained</h6>

<p>该关键字与<strong>weak一样，也是弱参照，与</strong>weak的区别只是是否执行nil赋值(Zeroing)。但是这样，需要注意变量所指的对象已经被释放了，地址还还存在，但内存中对象已经没有了。如果还是访问该对象，将引起「BAD_ACCESS」错误。</p>

<h6>__autoreleasing</h6>

<p>该关键字使对像延迟释放。比如你想传一个未初始化的对像引用到一个方法当中，在此方法中实例化此对像，那么这种情况可以使用__autoreleasing。他被经常用于函数有值参数返回时的处理，比如下面的例子。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="nf">generateErrorInVariable:</span><span class="p">(</span><span class="n">__autoreleasing</span> <span class="n">NSError</span> <span class="o">**</span><span class="p">)</span><span class="nv">paramError</span> <span class="p">{</span>
</span><span class='line'>   <span class="p">....</span>
</span><span class='line'>      <span class="o">*</span><span class="n">paramError</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSError</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithDomain:</span><span class="s">@&quot;MyApp&quot;</span> <span class="nl">code:</span><span class="mi">1</span> <span class="nl">userInfo:</span><span class="n">errorDictionary</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">....</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>      <span class="n">NSError</span> <span class="o">*</span><span class="n">error</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>      <span class="p">[</span><span class="n">self</span> <span class="nl">generateErrorInVariable:</span><span class="o">&amp;</span><span class="n">error</span><span class="p">];</span>
</span><span class='line'>      <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Error = %@&quot;</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>又如函数的返回值是在函数中申请的，那么希望释放是在调用端时，往往有下面的代码。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">stringTest</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>      <span class="n">NSString</span> <span class="o">*</span><span class="n">retStr</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSString</span> <span class="nl">stringWithString:</span><span class="s">@&quot;test&quot;</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">return</span> <span class="p">[[</span><span class="n">retStr</span> <span class="n">retain</span><span class="p">]</span> <span class="n">autorelease</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 使用ARC</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">stringTest</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>      <span class="n">__autoreleasing</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">retStr</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSString</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithString:</span><span class="s">@&quot;test&quot;</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">return</span> <span class="n">retStr</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>即当方法的参数是id*，且希望方法返回时对象被autoreleased，那么使用该关键字。</p>

<h3>概括</h3>

<p>基本的ARC使用规则</p>

<ul>
<li>代码中不能使用retain, release, retain, autorelease</li>
<li>不重载dealloc（如果是释放对象内存以外的处理，是可以重载该函数的，但是不能调用[super dealloc]）</li>
<li>不能使用NSAllocateObject, NSDeallocateObject</li>
<li>不能在C结构体中使用对象指针</li>
<li>id与void *间的如果cast时需要用特定的方法（__bridge关键字）</li>
<li>不能使用NSAutoReleasePool、而需要@autoreleasepool块</li>
<li>不能使用“new”开始的属性名称 （如果使用会有下面的编译错误”Property’s synthesized getter follows Cocoa naming convention for returning ‘owned’ objects”）</li>
</ul>


<hr />

<h1><span id="2">ARC之@property使用</span></h1>

<h3>所有者属性</h3>

<p>我们先来看看与所有权有关系的属性，关键字间的对应关系。</p>

<table border="1">
    <tr>
        <td>属性值</td><td>关键字</td><td>所有权</td>
    </tr>
    <tr>
        <td>strong</td><td> __strong</td><td>有</td>
    </tr>
    <tr>
        <td>weak</td><td>__weak</td><td>无</td>
    </tr>
    <tr>
        <td>unsafe_unretained</td><td>__unsafe_unretained</td><td>无</td>
    </tr>
    <tr>
        <td>copy</td><td>__strong</td><td>有</td>
    </tr>
    <tr>
        <td>assign</td><td>__unsafe_unretained</td><td>无</td>
    </tr>
    <tr>
        <td>retain</td><td> __strong</td><td>有</td>
    <tr>
</table>


<h6>strong</h6>

<p>该属性值对应 __strong 关键字，即该属性所声明的变量将成为对象的持有者。</p>

<h6>weak</h6>

<p>该属性对应 __weak 关键字，与 __weak 定义的变量一致，该属性所声明的变量将没有对象的所有权，并且当对象被释放之后，对象将被自动赋值nil。</p>

<p>并且，delegate 和 Outlet 应该用 weak 属性来声明。同时，如上一回介绍的 iOS 5 之前的版本是没有 __weak 关键字的，所以 weak 属性是不能使用的。这种情况我们使用 unsafe_unretained。</p>

<h6>unsafe_unretained</h6>

<p>等效于__unsafe_unretaind关键字声明的变量；像上面说明的，iOS 5之前的系统用该属性代替 weak 来使用。</p>

<h6>copy</h6>

<p>与 strong 的区别是声明变量是拷贝对象的持有者。</p>

<h6>assign</h6>

<p>一般Scalar Varible用该属性声明，比如,int, BOOL。</p>

<h6>retain</h6>

<p>该属性与 strong 一致；只是可读性更强一些。</p>

<h3>读写相关的属性 (readwrite, readonly)</h3>

<p>读写相关的属性有 readwrite 和 readonly 两种，如果使用ARC之后，那么需要注意一下 readonly 属性的使用。</p>

<p>比如下面的变量声明。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">readonly</span><span class="p">)</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>一般声明为 readonly 的变量按理说应该不需要持有所有权了，但是在ARC有效的情况下，将出现下面的错误信息 ：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="err">“</span><span class="n">ARC</span> <span class="n">forbids</span> <span class="n">synthesizing</span> <span class="n">a</span> <span class="n">property</span> <span class="n">of</span> <span class="n">an</span> <span class="n">Objective</span><span class="o">-</span><span class="n">C</span> <span class="n">object</span> <span class="n">with</span> <span class="n">unspecified</span> <span class="n">ownership</span> <span class="n">or</span> <span class="n">storage</span> <span class="n">attribute</span><span class="err">”</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果定义了ARC有效，那么必须要有所有者属性的定义；所以我们的代码改成这样，就OK了</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">strong</span><span class="p">,</span> <span class="n">readonly</span><span class="p">)</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>不过有一点，Scalar Varible的变量缺省都有 assign 的属性定义，所以不需要给他们单独的明示声明了。</p>

<hr />

<h1><span id="3">ARC产生缘由</span></h1>

<h3>Objective-C 内存管理</h3>

<p>和许多面向对象语言一样，Objective-C 中内存管理的方式其实就是指 引用计数 （Reference Counting）的使用准则。如下图所示，对象生成的时候必定被某个持有者拿着，如果有多个持有者的话，其引用计数就会递增；相反失去一个持有者那么引用计数即会递减，直到失去所有的持有者，才真正地从内测中释放自己</p>

<p><img src="http://gbammc.github.io/images/arc/ARC1.png"></p>

<h3>基本原则</h3>

<p>内存管理的依循下面的基本原则</p>

<ul>
<li>自己生成的对象，那么既是其持有者</li>
<li>不是自己生成的对象，也可成为其持有者（一个对象可以被多个人持有）</li>
<li>如果不想持有对象的时候，必须释放其所有权</li>
<li>不能释放已不再持有所有权的对象</li>
</ul>


<p>结合 Objective-C 语言中的方法，我们来看看基本的内存管理。</p>

<table border="1">
<thead>
    <tr>
        <th>方法</th>
        <th>动作</th>
    </tr>
</thead>
<tbody>
    <tr>
        <td>alloc/new/copy/mutableCopy</td>
        <td>生成对象并拥有所有权</td>
    </tr>
    <tr>
        <td>retain</td>
        <td>拥有对象所有权</td>
    </tr>
    <tr>
        <td>release</td>
        <td>释放对象所有权</td>
    </tr>
    <tr>
        <td>dealloc</td>
        <td>释放对象资源</td>
    </tr>
</tbody>
</table>


<p>Objective-C 语言内部严格遵守上面表格中的定义；首先是 alloc/new/copy/mutableCopy 这几个函数，并且是alloc/new/copy/mutableCopy 开头的函数，比如：allpcMyObject/newTheObject/copyThis/mutableCopyTheObject 等都必须遵循这个原则。</p>

<p>反而言之，如果不是 alloc/new/copy/mutableCopy 开头的函数，而且要返回对象的话，那么调用端只是生成对象，而不是其持有者。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">allocObject</span> <span class="p">{</span>
</span><span class='line'>      <span class="cm">/*</span>
</span><span class='line'><span class="cm">     * 生成对象并拥有所有权</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>      <span class="kt">id</span> <span class="n">obj</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSObject</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>      <span class="cm">/*</span>
</span><span class='line'><span class="cm">     * 自己一直是持有对象状态</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">obj</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如上面的例子，alloc 生成的对象，其所有权会传递给函数的调用端；即满足了 alloc 开头函数的命名规则。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">object</span> <span class="p">{</span>
</span><span class='line'>      <span class="kt">id</span> <span class="n">obj</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSObject</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>      <span class="cm">/*</span>
</span><span class='line'><span class="cm">     * 自己一直是持有对象状态</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>
</span><span class='line'>      <span class="p">[</span><span class="n">obj</span> <span class="n">autorelease</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>      <span class="cm">/*</span>
</span><span class='line'><span class="cm">     * 对象还存在，只是并不持有它的所有权</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">return</span> <span class="n">obj</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里我们用到了 autorelease 函数。它的作用既是将对象放入 NSAutoreleasePool 中，由其来维护其生命周期。换句话说对象的持有者是 NSAutoreleasePool；上面的例子中，object 返回后，调用者将不持有其所有权。（除非再调用 retain。）</p>

<p>用 autorelease 的一个理由既是让程序员来控制对象的存活周期，而不像 C/C++ 等语言中，出栈后，栈中数据都被自动废弃，或者用 { } 框住的自动变量，当出了范围就看不到了。在 Objective-C 中，只有当 [pool drain] 被调用的时候，才清空 pool 中所有登录的对象实体，在这之前，你可以像往常一样正常使用对象。</p>

<p>当然可以想象得到的，如果一个程序只有一个 NSAutoreleasePool，并在 main 中声明，程序结束时才 [pool drain]/[pool release] 的话，那么所有 autorelease 的对象都将塞满这个 pool，会耗掉系统大部分内存。所以，使用 NSAutoreleasePool 的时候也尽量建议局部使用。</p>

<h3>MRC编程准则</h3>

<p>基于以上原则，在 ARC 诞生之前，我们往往用下面准则来写代码。</p>

<ul>
<li><h4>生成对象时，使用autorelease</h4></li>
</ul>


<p>一般情况下，我们这样生成对象并使用</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">MyController</span><span class="o">*</span> <span class="n">controller</span> <span class="o">=</span> <span class="p">[[</span><span class="n">MyController</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'><span class="c1">// ......</span>
</span><span class='line'><span class="p">[</span><span class="n">controller</span> <span class="n">release</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果在 [controller release] 之前函数return了怎么样，内存泄露了不是；为了防患于未然，一般像下面一样 生成对象时，使用autorelease。这样一来，该对象就被自动加入到最近的那个 pool 中。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">MyController</span><span class="o">*</span> <span class="n">controller</span> <span class="o">=</span> <span class="p">[[[</span><span class="n">MyController</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">]</span> <span class="n">autorelease</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><h4>对象赋值时，先autorelease后再retain</h4></li>
</ul>


<p>对象赋值的时候，如果之前不将变量所持有的对象释放，那么很可能引起内存泄露。比如下面的代码</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">{</span>
</span><span class='line'>      <span class="n">_member</span> <span class="o">=</span> <span class="p">[[</span><span class="n">TempValue</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">setValue:</span><span class="p">(</span><span class="n">TempValue</span> <span class="o">*</span><span class="p">)</span><span class="n">value</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">_member</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
</span><span class='line'>  <span class="c1">// 这时，之前持有的对象因为没有 release 而引起内存泄露</span>
</span><span class='line'>  <span class="c1">// 当然，先 [_member release] 后再代入也是可以的，</span>
</span><span class='line'>  <span class="c1">// 但是当与「对象在函数中返回时」的问题一同考虑时，</span>
</span><span class='line'>  <span class="c1">// 如果没有 return [[object retain] autorelease] 的保证，这里即使 [_member release]也是百搭</span>
</span><span class='line'>  <span class="c1">// 详细的解释见下</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>鉴于以上原因，我们将原先的对象先autorelease后再将新对象retain赋值。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">_member</span> <span class="o">=</span> <span class="p">[[</span><span class="n">TempValue</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>  <span class="c1">// 这里，即使使用【生成对象时，使用autorelease】的准则，也没有关系</span>
</span><span class='line'>  <span class="c1">// 使用autorelease一次就将制定对象放入pool中，放几次[pool drain]的时候就释放几次</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">setValue:</span><span class="p">(</span><span class="n">TempValue</span> <span class="o">*</span><span class="p">)</span><span class="n">value</span> <span class="p">{</span>
</span><span class='line'>  <span class="p">[</span><span class="n">_member</span> <span class="n">autorelease</span><span class="p">];</span>
</span><span class='line'>  <span class="n">_member</span> <span class="o">=</span> <span class="p">[</span><span class="n">value</span> <span class="n">retain</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>该原则遵循 Failed Self 的原则，虽然从性能上看有所损耗但是保证了代码</p>

<ul>
<li><h4>对象在函数中返回时，使用return [[object retain] autorelease]</h4></li>
</ul>


<p>严格地说，是除 alloc/new/copy/mutableCopy 开头函数以外的函数中，有对象放回时，使用return [[object retain] autorelease]。</p>

<p><strong>我们结合下面的例子来说明，并总结出该问题的几种解决方案</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@implementation</span> <span class="nc">FooClass</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setObject:</span><span class="p">(</span><span class="n">MyObject</span> <span class="o">*</span><span class="p">)</span><span class="nv">object</span><span class="p">;</span>
</span><span class='line'> <span class="p">{</span>
</span><span class='line'>     <span class="c1">// 这里故意没有使用 autorelease，以便说明问题</span>
</span><span class='line'>     <span class="p">[</span><span class="n">_object</span> <span class="n">release</span><span class="p">];</span>
</span><span class='line'>     <span class="n">_object</span> <span class="o">=</span> <span class="p">[</span><span class="n">object</span> <span class="n">retain</span><span class="p">];</span>
</span><span class='line'> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="n">object</span><span class="p">;</span>
</span><span class='line'> <span class="p">{</span>
</span><span class='line'>     <span class="k">return</span> <span class="n">_object</span><span class="p">;</span>
</span><span class='line'> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">dealloc</span><span class="p">;</span>
</span><span class='line'> <span class="p">{</span>
</span><span class='line'>     <span class="p">[</span><span class="n">_object</span> <span class="n">release</span><span class="p">];</span>
</span><span class='line'>     <span class="p">[</span><span class="n">super</span> <span class="n">dealloc</span><span class="p">];</span>
</span><span class='line'> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">BarClass</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">doStuff</span><span class="p">;</span>
</span><span class='line'> <span class="p">{</span>
</span><span class='line'>    <span class="n">FooClass</span> <span class="o">*</span> <span class="n">foo</span> <span class="o">=</span> <span class="p">[[</span><span class="n">FooClass</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 创建第一个对象，引用计数 = 1</span>
</span><span class='line'>    <span class="n">MyObject</span> <span class="o">*</span> <span class="n">firstObject</span> <span class="o">=</span> <span class="p">[[</span><span class="n">MyObject</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="c1">// setObject中由于 [object retain] ，引用计数 = 2</span>
</span><span class='line'>    <span class="p">[</span><span class="n">foo</span> <span class="nl">setObject:</span><span class="n">firstObject</span><span class="p">];</span>
</span><span class='line'>    <span class="c1">// 释放一次，引用计数 = 1；这之后对象有正确的所有权属性</span>
</span><span class='line'>    <span class="p">[</span><span class="n">firstObject</span> <span class="n">release</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 通过非 alloc/new/copy/mutableCopy 开头函数得到对象</span>
</span><span class='line'>    <span class="c1">// anObject 指向第一个对象，但是并没有其所有权，对象引用计数 = 1</span>
</span><span class='line'>    <span class="n">MyObject</span> <span class="o">*</span> <span class="n">anObject</span> <span class="o">=</span> <span class="p">[</span><span class="n">foo</span> <span class="n">object</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">anObject</span> <span class="n">testMethod</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 创建第二个对象</span>
</span><span class='line'>    <span class="n">MyObject</span> <span class="o">*</span> <span class="n">secondObject</span> <span class="o">=</span> <span class="p">[[</span><span class="n">MyObject</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="c1">// setObject中由于 [_object release]; 第一个对象引用计数 = 0，内存被释放</span>
</span><span class='line'>    <span class="p">[</span><span class="n">foo</span> <span class="nl">setObject:</span><span class="n">secondObject</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">secondObject</span> <span class="n">release</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 程序在这里崩溃了，因为 anObject 指向了一个空地址</span>
</span><span class='line'>    <span class="p">[</span><span class="n">anObject</span> <span class="n">testMethod</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><h4>生成对象时，使用autorelease</h4></li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@implementation</span> <span class="nc">BarClass</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">doStuff</span><span class="p">;</span>
</span><span class='line'> <span class="p">{</span>
</span><span class='line'>    <span class="n">FooClass</span> <span class="o">*</span> <span class="n">foo</span> <span class="o">=</span> <span class="p">[[</span><span class="n">FooClass</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">MyObject</span> <span class="o">*</span> <span class="n">firstObject</span> <span class="o">=</span> <span class="p">[[[</span><span class="n">MyObject</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">]</span> <span class="n">autorelease</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">foo</span> <span class="nl">setObject:</span><span class="n">firstObject</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">MyObject</span> <span class="o">*</span> <span class="n">anObject</span> <span class="o">=</span> <span class="p">[</span><span class="n">foo</span> <span class="n">object</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">anObject</span> <span class="n">testMethod</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">MyObject</span> <span class="o">*</span> <span class="n">secondObject</span> <span class="o">=</span> <span class="p">[[[</span><span class="n">MyObject</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">]</span> <span class="n">autorelease</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">foo</span> <span class="nl">setObject:</span><span class="n">secondObject</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="n">anObject</span> <span class="n">testMethod</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>对象生成时，即被放入最近的 pool 中，不需要人为特殊的维护，对象的生命周期将被延续，出 {} 范围之时即对象释放之际。</p>

<ul>
<li><h4>对象代入时，先autorelease后再retain</h4></li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setObject:</span><span class="p">(</span><span class="n">MyObject</span> <span class="o">*</span><span class="p">)</span><span class="nv">object</span><span class="p">;</span>
</span><span class='line'> <span class="p">{</span>
</span><span class='line'>     <span class="p">[</span><span class="n">_object</span> <span class="n">autorelease</span><span class="p">];</span>
</span><span class='line'>     <span class="n">_object</span> <span class="o">=</span> <span class="p">[</span><span class="n">object</span> <span class="n">retain</span><span class="p">];</span>
</span><span class='line'> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="n">object</span><span class="p">;</span>
</span><span class='line'> <span class="p">{</span>
</span><span class='line'>     <span class="c1">// 遵循非 alloc/new/copy/mutableCopy 开头的函数，不赐予所有权原则</span>
</span><span class='line'>     <span class="k">return</span> <span class="n">_object</span><span class="p">;</span>
</span><span class='line'> <span class="p">}</span>
</span><span class='line'> <span class="err">```</span>
</span><span class='line'>  
</span><span class='line'><span class="err">同样的，对象被放入最近的</span> <span class="n">pool</span> <span class="err">中，第二次</span> <span class="n">setObject</span> <span class="err">后对象引用计数仍为</span><span class="mi">1</span><span class="err">，</span> <span class="n">pool</span> <span class="err">清空时才执行最后一次对象</span><span class="n">release</span><span class="err">，从而保证了代码的正确性。</span>
</span><span class='line'>
</span><span class='line'><span class="o">*</span> <span class="err">####对象在函数中返回时，使用</span><span class="k">return</span> <span class="p">[[</span><span class="n">object</span> <span class="n">retain</span><span class="p">]</span> <span class="n">autorelease</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p> objc
&ndash; (void)setObject:(MyObject *)object;
 {</p>

<pre><code> [_object release];
 _object = [object retain];
</code></pre>

<p> }</p>

<ul>
<li>(id)object;
{
   // 遵循非 alloc/new/copy/mutableCopy 开头的函数，不赐予所有权原则
   return [[_object retain] autorelease];
}
&#8220;`</li>
</ul>


<p>好不容易回到了本小节要说明的方法；可以看到这是从另一个角度解决了该问题：[foo object] 的时候保证引用计数是2，并将对象放入pool中维护。</p>

<h3>ARC编程准则</h3>

<p>在ARC中，如果不是 alloc/new/copy/mutableCopy 开头的函数，编译器会将生成的对象自动放入 autoReleasePool 中。如果是 __strong 修饰的变量，编译器会自动给其加上所有权。等等，详细，我们根据不同的关键字来看看编译器为我们具体做了什么。并从中总结出 ARC 的使用规则。</p>

<ul>
<li><h4>__strong</h4></li>
</ul>


<p>先来看看用 __strong 修饰的变量，以及缺省隐藏的 __strong 情况。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="cm">/*</span>
</span><span class='line'><span class="cm">     * 生成对象并拥有所有权</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kt">id</span> <span class="n">__strong</span> <span class="n">obj</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSObject</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/*</span>
</span><span class='line'><span class="cm">     * 自己一直是持有对象状态</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>    <span class="cm">/*</span>
</span><span class='line'><span class="cm">     * 变量出生命周期时，失去全部所有者，对象内存空间被释放</span>
</span><span class='line'><span class="cm">     */</span>
</span></code></pre></td></tr></table></div></figure>


<p>这种情况毫无悬念，缺省使用 alloc/new/copy/mutableCopy 开头的函数也是这样的结果。并且在这里，编译器帮我们自动的调用了对象的 release 函数，不需要手工维护。再看看下面的情况。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="cm">/*</span>
</span><span class='line'><span class="cm">     * 生成对象但是并没有其所有权</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kt">id</span> <span class="n">__strong</span> <span class="n">obj</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableArray</span> <span class="n">array</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/*</span>
</span><span class='line'><span class="cm">     * 由于变量声明是强引用，自己一直是持有对象状态</span>
</span><span class='line'><span class="cm">     * 编译器根据函数名，再将该对象放入 autoreleasepool 中</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>    <span class="cm">/*</span>
</span><span class='line'><span class="cm">     * 变量出生命周期时，失去全部所有者，对象内存空间被释放</span>
</span><span class='line'><span class="cm">     */</span>   
</span></code></pre></td></tr></table></div></figure>


<p>由上，虽然不是用 alloc/new/copy/mutableCopy 开头的函数得到的对象，由于是强参照，我们仍然成为对象的持有者。而这，正是编译器帮我们做到的。</p>

<pre><code>具体做的是什么呢？其实就是【对象在函数中返回时，使用return [[object retain] autorelease]】所描述的；如果你反汇编一下ARC生成的代码，可以看到这时会自动调用名为 objc_retainAutoreleaseReturnValue 的函数，而其作用和 [[object retain] autorelease] 一致。编译器通过函数名分析，如果不是 alloc/new/copy/mutableCopy 开头的函数，自动加入了这段代码。    
</code></pre>

<p>另外，缺省 __strong 修饰的变量，对象代入的时候也正确地保证对象所有者规则；代入新对象时，自动释放旧对象的参照，代入nil的时候，表示释放当前对象的强参照。</p>

<ul>
<li><h4>__weak</h4></li>
</ul>


<p>虽然大部分场合，大部分问题使用 _<em>strong 来编码就足够了；但是为了解决循环参照的问题 _</em>weak 关键字修饰【弱参照】变量就发挥了左右。关于循环参照的问题，准备在以后的博文中介绍；今天，主要看看编译器在背后怎么处理 __weak 变量的。</p>

<p>__weak 声明的变量其实是被放入一个weak表中，该表和引用计数的表格类似，是一个Hash表，都是以对象的内存地址做key，同时，针对一个对象地址的key，可以同时对应多个变量的地址。</p>

<p><strong>当一个 __weak 所指对象被释放时，系统按下面步骤来处理</strong></p>

<ul>
<li>从weak表中，通过对象地址（key）找到entry</li>
<li>将entry中所有指向该对象的变量设为nil</li>
<li>从weak表中删除该entry</li>
<li>从对象引用计数表中删除对象entry(通过通过对象地址找到)</li>
</ul>


<p>另外，当使用 __weak 修饰的变量的时候，变量将放入 autoreleasepool 中，并且用几次放几次。比如下面的简单例子。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">id</span> <span class="n">__weak</span> <span class="n">o</span> <span class="o">=</span> <span class="n">obj</span><span class="p">;</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;1 %@&quot;</span><span class="p">,</span> <span class="n">o</span><span class="p">);</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;2 %@&quot;</span><span class="p">,</span> <span class="n">o</span><span class="p">);</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;3 %@&quot;</span><span class="p">,</span> <span class="n">o</span><span class="p">);</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;4 %@&quot;</span><span class="p">,</span> <span class="n">o</span><span class="p">);</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;5 %@&quot;</span><span class="p">,</span> <span class="n">o</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里我们用了5次，那么pool中就被登录了5次；从效率上考虑这样当然不是很好，可以通过代入 __strong 修饰的强参照变量来避开这个问题。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">id</span> <span class="n">__weak</span> <span class="n">o</span> <span class="o">=</span> <span class="n">obj</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">id</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">o</span><span class="p">;</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;1 %@&quot;</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;2 %@&quot;</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;3 %@&quot;</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;4 %@&quot;</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;5 %@&quot;</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>另外，还有通过重载 allowsWeakReference/retainWeakReference 函数来限制 __weak 声明变量使用回数的方法，毕竟不在本次讨论范畴之内，就此省略。</p>

<p>话说回来，为什么使用弱参照变量的时候，要将其放入 autoreleasepool 中呢？想想弱参照的定义就应该明白了 —- 如果在访问弱参照对象时，该对象被释放了怎么办，程序不就崩溃了嘛；所以为了解决该问题，又再一次用到了 pool。</p>

<ul>
<li><h5>__autoreleasing</h5></li>
</ul>


<p>虽然上面还没有讲到该关键字，但是编译器在很多时候已经用到了 autoreleasepool。比如非 alloc/new/copy/mutableCopy 开头的函数返回一个对象的时候，又比如使用一个 __weak 声明的变量的时候。</p>

<p>实际上，写ARC代码的时候，明示 __autoreleasing 声明变量和明示 __strong 声明变量一样基本上没有，因为编译器已经为我们做了很多，很智能了（前提是我们要按ARC的规则写代码）。</p>

<p>还有一种编译器缺省使用 __autoreleasing 关键字声明变量的时候：对象指针类型。比如下面的对应关系。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">id</span> <span class="o">*</span><span class="n">obj</span> <span class="o">==</span> <span class="kt">id</span> <span class="n">__autoreleasing</span> <span class="o">*</span><span class="n">obj</span>
</span><span class='line'>      <span class="n">NSObject</span> <span class="o">**</span><span class="n">obj</span> <span class="o">==</span> <span class="n">NSObject</span> <span class="o">*</span> <span class="n">__autoreleasing</span> <span class="o">*</span><span class="n">obj</span>
</span></code></pre></td></tr></table></div></figure>


<p>所以，下面两个函数的是等价的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">performOperationWithError:</span><span class="p">(</span><span class="n">NSError</span> <span class="o">**</span><span class="p">)</span><span class="nv">error</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">performOperationWithError:</span><span class="p">(</span><span class="n">NSError</span> <span class="o">*</span> <span class="n">__autoreleasing</span> <span class="o">*</span><span class="p">)</span><span class="nv">error</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>像下面的函数调用，为什么是可行的呢？</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">NSError</span> <span class="n">__strong</span> <span class="o">*</span><span class="n">error</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'><span class="kt">BOOL</span> <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">obj</span> <span class="nl">performOperationWithError:</span><span class="o">&amp;</span><span class="n">error</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>其实，编译器是这样解释这段代码的</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">NSError</span> <span class="n">__strong</span> <span class="o">*</span><span class="n">error</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'><span class="n">NSError</span> <span class="n">__autoreleasing</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">error</span><span class="p">;</span>
</span><span class='line'><span class="kt">BOOL</span> <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">obj</span> <span class="nl">performOperationWithError:</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">];</span>
</span><span class='line'><span class="n">error</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>那么我们这样声明函数不就可以了吗？</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">performOperationWithError:</span><span class="p">(</span><span class="n">NSError</span> <span class="o">*</span> <span class="n">__strong</span> <span class="o">*</span><span class="p">)</span><span class="nv">error</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>答案是肯定的，你可以这样做，编译是可以通过，但你违反了非 alloc/new/copy/mutableCopy 开头的函数，不返回对象持有权的原则。这里是没有问题了，但也许影响到其他地方NG。</p>

<h3>ARC 规则</h3>

<p><strong>结合上面的讲解，我想你也应该能够总结出来使用ARC时的规则</strong>
（这里只列出本讲中涉及的内容，其他的内容以后总结）</p>

<ul>
<li>代码中不能使用retain, release, retain, autorelease</li>
<li>不能使用NSAllocateObject, NSDeallocateObject</li>
<li>不能使用NSAutoReleasePool、而需要@autoreleasepool块</li>
<li>严守内存管理相关函数命名规则</li>
</ul>


<p>关于函数命名，伴随ARC的导入，还有一系列函数的定义也被严格定义了，那就是以 init 开头的函数。init 函数作为alloc生成对象的初期化函数，需要按原样直接传递对象给调用段，所以下面的声明是OK的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">initWithObject:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">obj</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>而下面的是NG的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">initWithObject</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<hr />

<h1><span id="4">ARC之循环引用</span></h1>

<h3>概念</h3>

<p>当我们使用强参照（Strong reference）时，往往需要留意 <strong>循环参照</strong> 的问题。循环参照指的是两个对象被互相强参照，以至于任一对象都不能释放。</p>

<p>一般情况下，当对象之间有“父子关系”时，强参照的情况发生的比较多。比如通讯薄对象AddrBook和每个通讯录Entry的关系如下。</p>

<p><img src="http://gbammc.github.io/images/arc/arc_reference_cycle_1.png"></p>

<p>这种情况下，由于Entry对象被AddrBook强参照，所以不能释放。另一方面，如果Entry被释放了，AddrBook对象的强参照也就没有了，其对象也应被释放。</p>

<h3>解决方式</h3>

<p>像上面的例子，当多个对象间有“父子关系”时，需要在一侧用“弱参照”来解决循环参照问题。一般情况下，“父亲”作为“孩子”的拥有者，对“孩子”是强参照，而“孩子”对父亲是弱参照。</p>

<p><img src="http://gbammc.github.io/images/arc/arc_reference_cycle_2.png"></p>

<p>如图所示，当强参照AddrBook对象的变量被释放的时候，AddrBook对象将被自动释放，同时将失去Entry成员对象的强参照。另外，当AddrBook对象被释放的时候，Entry对象中的AddrBook变量也将由Zeroing机制，自动带入nil。我们不需要担心释放对象的再访问问题。</p>

<p>下面，我们将看看有几种情况下，需要注意循环参照问题。</p>

<h3>Delegate模式</h3>

<p>iOS程序中经常用到delegate模式，比如ViewController中，用ModalView打开/关闭DetailViewController时，需要delegate的设定。</p>

<p><img src="http://gbammc.github.io/images/arc/arc_reference_cycle_3.png"></p>

<p>这里，ViewController对象中强参照detailViewController，如果DetailViewController的delegate不是弱参照ViewController话，将引起循环参照。</p>

<p>另外，当类中使用weak @property声明的delegate变量时，如果参照对象被释放，该变量将被自动设为nil，不需要程序代码设置。</p>

<h3>Blocks</h3>

<p>Blocks是iOS 4开始导入的，可以理解为python或者lisp中的Lambda，C++11也已导入了该概念；类似概念ruby/smalltalk/JSP语言中也有定义。具体讲解见以后的文章，本节我们主要看看在Block中的循环参照问题。</p>

<p>比如，block对象用copy的属性定义时候，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">typedef</span> <span class="nf">void</span><span class="p">(</span><span class="o">^</span><span class="n">MyBlock</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">@interface</span> <span class="nc">MyObject</span> : <span class="nc">NSObject</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">copy</span><span class="p">)</span> <span class="n">MyBlock</span> <span class="n">block</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">str</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">performBlock</span><span class="p">;</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">MyObject</span>
</span><span class='line'><span class="k">@synthesize</span> <span class="n">block</span><span class="p">,</span> <span class="n">str</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">performBlock</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">block</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">self</span><span class="p">.</span><span class="n">block</span><span class="p">();</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>调用端如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">MyObject</span> <span class="o">*</span><span class="n">object</span> <span class="o">=</span> <span class="p">[[</span><span class="n">MyObject</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'><span class="n">object</span><span class="p">.</span><span class="n">str</span> <span class="o">=</span> <span class="s">@&quot;hoge&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="n">object</span><span class="p">.</span><span class="n">block</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;block: str=%@&quot;</span><span class="p">,</span> <span class="n">object</span><span class="p">.</span><span class="n">str</span><span class="p">);</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="p">[</span><span class="n">object</span> <span class="n">performBlock</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们看到，Block的构文中参照了object，同样object也强参照block。</p>

<p><img src="http://gbammc.github.io/images/arc/arc_reference_cycle_4.png"></p>

<p>为了解决该问题，我们可以有下面两种选择。</p>

<h6>使用__block关键字修饰</h6>

<p>使用__block关键字，让对象有读写权限，如果Block内的处理完毕就释放object。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">__block</span> <span class="n">MyObject</span> <span class="o">*</span><span class="n">object</span> <span class="o">=</span> <span class="p">[[</span><span class="n">MyObject</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'><span class="n">object</span><span class="p">.</span><span class="n">str</span> <span class="o">=</span> <span class="s">@&quot;hoge&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="n">object</span><span class="p">.</span><span class="n">block</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;block: str=%@&quot;</span><span class="p">,</span> <span class="n">object</span><span class="p">.</span><span class="n">str</span><span class="p">);</span>
</span><span class='line'>    <span class="n">object</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="p">[</span><span class="n">object</span> <span class="n">performBlock</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>该关键字的意思就是让block取消对object的强参照，以避免循环参照。但是，有一个问题就是，object的释放动作是在Block内部执行，如果Block没有被执行的话，循环参照一直存在。比如上面的代码，如果第8行 [object performBlock]; 没有执行的话，那么一直还是循环参照状态。</p>

<h6>使用__weak关键字修饰</h6>

<p>另一种方案就是让Block的参照变为弱参照。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">MyObject</span> <span class="o">*</span><span class="n">object</span> <span class="o">=</span> <span class="p">[[</span><span class="n">MyObject</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'><span class="n">object</span><span class="p">.</span><span class="n">str</span> <span class="o">=</span> <span class="s">@&quot;hoge&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="n">__weak</span> <span class="n">MyObject</span> <span class="o">*</span><span class="n">weakObject</span> <span class="o">=</span> <span class="n">object</span><span class="p">;</span>
</span><span class='line'><span class="n">object</span><span class="p">.</span><span class="n">block</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;block: str=%@&quot;</span><span class="p">,</span> <span class="n">weakObject</span><span class="p">.</span><span class="n">str</span><span class="p">);</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="p">[</span><span class="n">object</span> <span class="n">performBlock</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>考虑到异步通信时Blocks的使用情况，weak变量weakObject有可能随时变为nil，所以类似于下面先变为strong变量，并检查是否为nil的处理方式应该更安全。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">MyObject</span> <span class="o">*</span><span class="n">object</span> <span class="o">=</span> <span class="p">[[</span><span class="n">MyObject</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'><span class="n">object</span><span class="p">.</span><span class="n">str</span> <span class="o">=</span> <span class="s">@&quot;hoge&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="n">__weak</span> <span class="n">MyObject</span> <span class="o">*</span><span class="n">weakObject</span> <span class="o">=</span> <span class="n">object</span><span class="p">;</span>
</span><span class='line'><span class="n">object</span><span class="p">.</span><span class="n">block</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="n">MyObject</span> <span class="n">strongObject</span> <span class="o">=</span> <span class="n">weakObject</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">strongObject</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;block: str=%@&quot;</span><span class="p">,</span> <span class="n">strongObject</span><span class="p">.</span><span class="n">str</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="p">[</span><span class="n">object</span> <span class="n">performBlock</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>总上，当我们使用Blocks时，也需要考虑Block中变量和实例的关系，不要引起不必要的循环参照问题。</p>

<hr />

<h1><span id="5">ARC之Outlet与弱引用</span></h1>

<h3>使用weak property声明Outlet</h3>

<p>当我们使用 Interface Builder 生成Outlet对象的时候，一般都是作为 subview 来使用的。比如 UIViewController 的view。所以说Outlet的持有者就是superview对象，即有“父子”关系。我们知道，当对象间有“父子”关系时，需要使用弱参照，以避免“循环参照”。</p>

<p>ViewController 本身是不会作为Outlet的所有者的，所以使用weak property声明。</p>

<p><img src="http://gbammc.github.io/images/arc/arc_outlet_weak_property.png"></p>

<h3>简化viewDidUnload</h3>

<p>Outlet都使用weak property声明的时候，还有一个好处，就是简化viewDidUnload的处理。</p>

<p>iOS在系统内存不足的时候，UIViewController会将没有表示的所有view做unload处理，即调用viewDidUnload接口。</p>

<p>所以，如果是强参照的情况下，需要释放所有权，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="kt">IBOutlet</span> <span class="n">UILabel</span> <span class="o">*</span><span class="n">label</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>




<br>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidUnload</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">self</span><span class="p">.</span><span class="n">label</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span> <span class="c1">// 取消强参照，释放所有权</span>
</span><span class='line'>      <span class="p">[</span><span class="n">super</span> <span class="n">viewDidUnload</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果没有 self.label = nil 的处理，那么 UIViewController 将不会释放 label 的所有权；结果，系统是调用了unload，但是subview对象始终留在内存中。随着界面上控件的增多，内存泄露会越来越大。</p>

<p>如果使用的是weak property声明的话，会是怎样的呢？</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">weak</span><span class="p">)</span> <span class="kt">IBOutlet</span> <span class="n">UILabel</span> <span class="o">*</span><span class="n">label</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这时，系统在unload时，由于label没有被强参照，更加ARC的规则，这时，label的对象即被释放。并在释放的同时，变量自动指向nil。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidUnload</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// 这里什么也不用管</span>
</span><span class='line'>    <span class="p">[</span><span class="n">super</span> <span class="n">viewDidUnload</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>其实，如果我们的viewDidUnload只是用来释放Outlet用的话，那么该函数也可以不被重载的。</p>

<h3>什么时候要用strong property</h3>

<p>由上我们也可以看到，并不是所有的Outlet都用弱参照来声明都是正确的；当使用Interface Builder生成的第一层的view或者windows被作为Outlet来使用的话，那么是不能声明为弱参照property的。（比如，Storyboard的各个scene）</p>

<p>理由很简单，没有被任何人强参照的对象，生成之后就会立刻被释放。</p>

<p>综上，当我们使用Outlet的时候，注意不同的情况来使用strong或者是weak。</p>

<hr />

<h1><span id="6">ARC之对象转型</span></h1>

<h3>引子</h3>

<p>我们先来看一下ARC无效的时候，我们写id类型转void*类型的写法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">id</span> <span class="n">obj</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSObject</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'><span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">obj</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>反过来，当把void*对象变回id类型时，只是简单地如下来写，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">id</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
</span><span class='line'><span class="p">[</span><span class="n">obj</span> <span class="n">release</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>但是上面的代码在ARC有效时，就有了下面的错误：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="nl">error:</span> <span class="n">implicit</span> <span class="n">conversion</span> <span class="n">of</span> <span class="n">an</span> <span class="n">Objective</span><span class="o">-</span><span class="n">C</span> <span class="n">pointer</span>
</span><span class='line'>       <span class="n">to</span> <span class="err">’</span><span class="kt">void</span> <span class="o">*</span><span class="err">’</span> <span class="n">is</span> <span class="n">disallowed</span> <span class="n">with</span> <span class="n">ARC</span>
</span><span class='line'>       <span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">obj</span><span class="p">;</span>
</span><span class='line'>                 <span class="o">^</span>
</span><span class='line'>
</span><span class='line'><span class="nl">error:</span> <span class="n">implicit</span> <span class="n">conversion</span> <span class="n">of</span> <span class="n">a</span> <span class="n">non</span><span class="o">-</span><span class="n">Objective</span><span class="o">-</span><span class="n">C</span> <span class="n">pointer</span>
</span><span class='line'>    <span class="n">type</span> <span class="err">’</span><span class="kt">void</span> <span class="o">*</span><span class="err">’</span> <span class="n">to</span> <span class="err">’</span><span class="kt">id</span><span class="err">’</span> <span class="n">is</span> <span class="n">disallowed</span> <span class="n">with</span> <span class="n">ARC</span>
</span><span class='line'>    <span class="kt">id</span> <span class="n">o</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
</span><span class='line'>            <span class="o">^</span>
</span></code></pre></td></tr></table></div></figure>


<h3>__bridge</h3>

<p>为了解决这一问题，我们使用 __bridge 关键字来实现id类型与void*类型的相互转换。看下面的例子。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">id</span> <span class="n">obj</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSObject</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">__bridge</span> <span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">obj</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">id</span> <span class="n">o</span> <span class="o">=</span> <span class="p">(</span><span class="n">__bridge</span> <span class="kt">id</span><span class="p">)</span><span class="n">p</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>将Objective-C的对象类型用 <strong>bridge 转换为 void* 类型和使用 </strong>unsafe_unretained 关键字修饰的变量是一样的。被代入对象的所有者需要明确对象生命周期的管理，不要出现异常访问的问题。</p>

<p>除过 <strong>bridge 以外，还有两个 </strong>bridge 相关的类型转换关键字：</p>

<ul>
<li>__bridge_retained</li>
<li>__bridge_transfer</li>
</ul>


<p>接下来，我们将看看这两个关键字的区别。</p>

<h3>__bridge_retained</h3>

<p>先来看使用 __bridge_retained 关键字的例子程序：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">id</span> <span class="n">obj</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSObject</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">__bridge_retained</span> <span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">obj</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>从名字上我们应该能理解其意义：类型被转换时，其对象的所有权也将被变换后变量所持有。如果不是ARC代码，类似下面的实现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">id</span> <span class="n">obj</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSObject</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">obj</span><span class="p">;</span>
</span><span class='line'><span class="p">[(</span><span class="kt">id</span><span class="p">)</span><span class="n">p</span> <span class="n">retain</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以用一个实际的例子验证，对象所有权是否被持有。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>      <span class="kt">id</span> <span class="n">obj</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSObject</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>      <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">__bridge_retained</span> <span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">obj</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;class=%@&quot;</span><span class="p">,</span> <span class="p">[(</span><span class="n">__bridge</span> <span class="kt">id</span><span class="p">)</span><span class="n">p</span> <span class="n">class</span><span class="p">]);</span>
</span></code></pre></td></tr></table></div></figure>


<p>出了大括号的范围后，p 仍然指向一个有效的实体。说明他拥有该对象的所有权，该对象没有因为出其定义范围而被销毁。</p>

<h3>__bridge_transfer</h3>

<p>相反，当想把本来拥有对象所有权的变量，在类型转换后，让其释放原先所有权的时候，需要使用 __bridge_transfer 关键字。文字有点绕口，我们还是来看一段代码吧。</p>

<p>如果ARC无效的时候，我们可能需要写下面的代码。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// p 变量原先持有对象的所有权</span>
</span><span class='line'><span class="kt">id</span> <span class="n">obj</span> <span class="o">=</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="n">p</span><span class="p">;</span>
</span><span class='line'><span class="p">[</span><span class="n">obj</span> <span class="n">retain</span><span class="p">];</span>
</span><span class='line'><span class="p">[(</span><span class="kt">id</span><span class="p">)</span><span class="n">p</span> <span class="n">release</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>那么ARC有效后，我们可以用下面的代码来替换：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// p 变量原先持有对象的所有权</span>
</span><span class='line'><span class="kt">id</span> <span class="n">obj</span> <span class="o">=</span> <span class="p">(</span><span class="n">__bridge_transfer</span> <span class="kt">id</span><span class="p">)</span><span class="n">p</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看出来，__bridge_retained 是编译器替我们做了 retain 操作，而 __bridge_transfer 是替我们做了 release。</p>

<h3>Toll-Free bridged</h3>

<p>在iOS世界，主要有两种对象：Objective-C 对象和 Core Foundation 对象。Core Foundation 对象主要是有C语言实现的 Core Foundation Framework 的对象，其中也有对象引用计数的概念，只是不是 Cocoa Framework::Foundation Framework 的 retain/release，而是自身的 CFRetain/CFRelease 接口。</p>

<p>这两种对象间可以互相转换和操作，不使用ARC的时候，单纯的用C的类型转换，不需要消耗CPU的资源，所以叫做 Toll-Free bridged。比如 NSArray和CFArrayRef, NSString和CFStringRef，他们虽然属于不同的 Framework，但是具有相同的对象结构，所以可以用标准C的类型转换。</p>

<p>比如不使用ARC时，我们用下面的代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">NSString</span> <span class="o">*</span><span class="n">string</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSString</span> <span class="nl">stringWithFormat:</span><span class="p">...];</span>
</span><span class='line'><span class="n">CFStringRef</span> <span class="n">cfString</span> <span class="o">=</span> <span class="p">(</span><span class="n">CFStringRef</span><span class="p">)</span><span class="n">string</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>同样，Core Foundation类型向Objective-C类型转换时，也是简单地用标准C的类型转换即可。</p>

<p>但是在ARC有效的情况下，将出现类似下面的编译错误：</p>

<pre><code>Cast of Objective-C pointer type ‘NSString *’ to C pointer type ‘CFStringRef’ (aka ‘const struct __CFString *’) requires a bridged cast
Use __bridge to convert directly (no change in ownership)
Use __bridge_retained to make an ARC object available as a +1 ‘CFStringRef’ (aka ‘const struct __CFString *’)
</code></pre>

<p>错误中已经提示了我们需要怎样做：用 <strong>bridge 或者 </strong>bridge_retained 来转型，其差别就是变更对象的所有权。</p>

<p>正因为Objective-C是ARC管理的对象，而Core Foundation不是ARC管理的对象，所以才要特意这样转换，这与id类型向void*转换是一个概念。也就是说，当这两种类型（有ARC管理，没有ARC管理）在转换时，需要告诉编译器怎样处理对象的所有权。</p>

<p>上面的例子，使用 <strong>bridge/</strong>bridge_retained 后的代码如下：</p>

<h6>__bridge</h6>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">NSString</span> <span class="o">*</span><span class="n">string</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSString</span> <span class="nl">stringWithFormat:</span><span class="p">...];</span>
</span><span class='line'><span class="n">CFStringRef</span> <span class="n">cfString</span> <span class="o">=</span> <span class="p">(</span><span class="n">__bridge</span> <span class="n">CFStringRef</span><span class="p">)</span><span class="n">string</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>只是单纯地执行了类型转换，没有进行所有权的转移，也就是说，当string对象被释放的时候，cfString也不能被使用了。</p>

<h6>__bridge_retained</h6>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">NSString</span> <span class="o">*</span><span class="n">string</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSString</span> <span class="nl">stringWithFormat:</span><span class="p">...];</span>
</span><span class='line'><span class="n">CFStringRef</span> <span class="n">cfString</span> <span class="o">=</span> <span class="p">(</span><span class="n">__bridge_retained</span> <span class="n">CFStringRef</span><span class="p">)</span><span class="n">string</span><span class="p">;</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="n">CFRelease</span><span class="p">(</span><span class="n">cfString</span><span class="p">);</span> <span class="c1">// 由于Core Foundation的对象不属于ARC的管理范畴，所以需要自己release</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用 __bridge_retained 可以通过转换目标处（cfString）的 retain 处理，来使所有权转移。即使 string 变量被释放，cfString 还是可以使用具体的对象。只是有一点，由于Core Foundation的对象不属于ARC的管理范畴，所以需要自己release。</p>

<p>实际上，Core Foundation 内部，为了实现Core Foundation对象类型与Objective-C对象类型的相互转换，提供了下面的函数。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">CFTypeRef</span>  <span class="nf">CFBridgingRetain</span><span class="p">(</span><span class="kt">id</span>  <span class="n">X</span><span class="p">)</span>  <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span>  <span class="p">(</span><span class="n">__bridge_retained</span>  <span class="n">CFTypeRef</span><span class="p">)</span><span class="n">X</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">id</span>  <span class="nf">CFBridgingRelease</span><span class="p">(</span><span class="n">CFTypeRef</span>  <span class="n">X</span><span class="p">)</span>  <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span>  <span class="p">(</span><span class="n">__bridge_transfer</span>  <span class="kt">id</span><span class="p">)</span><span class="n">X</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>所以，可以用 CFBridgingRetain 替代 __bridge_retained 关键字：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">NSString</span> <span class="o">*</span><span class="n">string</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSString</span> <span class="nl">stringWithFormat:</span><span class="p">...];</span>
</span><span class='line'><span class="n">CFStringRef</span> <span class="n">cfString</span> <span class="o">=</span> <span class="n">CFBridgingRetain</span><span class="p">(</span><span class="n">string</span><span class="p">);</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="n">CFRelease</span><span class="p">(</span><span class="n">cfString</span><span class="p">);</span> <span class="c1">// 由于Core Foundation不在ARC管理范围内，所以需要主动release。</span>
</span></code></pre></td></tr></table></div></figure>


<h6>__bridge_transfer</h6>

<p>所有权被转移的同时，被转换变量将失去对象的所有权。当Core Foundation对象类型向Objective-C对象类型转换的时候，会经常用到 __bridge_transfer 关键字。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">CFStringRef</span> <span class="n">cfString</span> <span class="o">=</span> <span class="n">CFStringCreate</span><span class="p">...();</span>
</span><span class='line'><span class="n">NSString</span> <span class="o">*</span><span class="n">string</span> <span class="o">=</span> <span class="p">(</span><span class="n">__bridge_transfer</span> <span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">cfString</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// CFRelease(cfString); 因为已经用 __bridge_transfer 转移了对象的所有权，所以不需要调用 release</span>
</span></code></pre></td></tr></table></div></figure>


<p>同样，我们可以使用 CFBridgingRelease() 来代替 __bridge_transfer 关键字。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">CFStringRef</span> <span class="n">cfString</span> <span class="o">=</span> <span class="n">CFStringCreate</span><span class="p">...();</span>
</span><span class='line'><span class="n">NSString</span> <span class="o">*</span><span class="n">string</span> <span class="o">=</span> <span class="n">CFBridgingRelease</span><span class="p">(</span><span class="n">cfString</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<h3>总结</h3>

<p>由上面的学习我们了解到 ARC 中类型转换的用法，那么我们实际使用中按照怎样的原则或者方法来区分使用呢，下面我总结了几点关键要素。</p>

<ul>
<li>明确被转换类型是否是 ARC 管理的对象</li>
<li>Core Foundation 对象类型不在 ARC 管理范畴内</li>
<li>Cocoa Framework::Foundation 对象类型（即一般使用到的Objectie-C对象类型）在 ARC 的管理范畴内</li>
<li>如果不在 ARC 管理范畴内的对象，那么要清楚 release 的责任应该是谁</li>
<li>各种对象的生命周期是怎样的</li>
</ul>


<p>1 . 声明 id obj 的时候，其实是缺省的申明了一个 __strong 修饰的变量，所以编译器自动地加入了 retain 的处理，所以说 __bridge_transfer 关键字只为我们做了 release 处理。</p>

<hr />

<h1><span id="7">最终归纳</span></h1>

<h3>内存管理基本原则</h3>

<p>内存管理依循下面的基本原则:</p>

<ul>
<li>自己生成的对象，那么即是其持有者</li>
<li>不是自己生成的对象，也可成为其持有者（一个对象可以被多个人持有）</li>
<li>如果不想持有对象的时候，必须释放其所有权</li>
<li>不能释放已不再持有所有权的对象</li>
</ul>


<p><strong>不管ARC有没有效，该原则始终存在。</strong></p>

<h3>所有权关键字</h3>

<p>从代码上看，有ARC的代码和没有ARC的代码区别就在下面的几个关键字。</p>

<p>类似 NSObject* 的对象类型，或者 id 类型(<a href="http://www.yifeiyang.net/iphone-development-introduction-7-from-the-c-c-language-to-objective-c-language/">关于Objective-C对象的解释，可以参考iPhone开发入门（7）— 从C/C++语言到Objective-C语言</a>)，当ARC有效的时候，根据具体情况，这些关键字必须要使用(当然，如果你不写，编译器会用缺省的值代替)。</p>

<ul>
<li>__strong</li>
<li>__weak</li>
<li>__unsafe_unretained</li>
<li>__autoreleasing</li>
</ul>


<p>__strong是默认的修饰符。</p>

<p>__weak修饰了一个自动nil的weak引用。</p>

<p>__unsafe_unretained声明了一个不会自动nil的weak引用。当变量被释放，那么它就变成了一个野指针了。</p>

<p>__autoreleasing 用来修饰一个声明为 (id *) 的函数的参数，当函数返回值时被释放。</p>

<h3>ARC使用准则</h3>

<p>为了避免程序秒退的尴尬，使用ARC时，我们的代码必须遵循下面的准则。</p>

<ul>
<li>不能使用 retain/release/retainCount/autorelease</li>
<li>不能使用 NSAllocateObject/NSDeallocateObject</li>
<li>不能使用 NSZone</li>
<li>不能明示调用dealloc</li>
<li>内存管理相关的函数必须遵循命名规则</li>
<li>使用@autoreleasepool代替NSAutoreleasePool</li>
<li>Objective-C 对象不能作为C语言结构体（struct/union）的成员</li>
<li>【id】与【void*】之间需要明示cast</li>
</ul>


<p>建议使用Objective-C的class来管理数据格式，来代替C语言的struct。不能隐式转换 id 和 void *。</p>

<p>让我们一个一个来分析</p>

<ul>
<li><h4>不能使用 retain/release/retainCount/autorelease</h4></li>
</ul>


<p>内存管理完全交给编译器去做，所以之前内存相关的函数(retain/release/retainCount/autorelease)不能出现在程序中。Apple的ARC文档中也有下面的说明。</p>

<pre><code>ARC 有效后，不需要再次使用retain 和 release
</code></pre>

<p>如果我们在程序中使用这些函数，会得到类似下面的编译错误信息。</p>

<pre><code>error: ARC forbids explicit message send of ’release’
     [o release];
      ^ ~~~~~~~
</code></pre>

<ul>
<li><h4>不能使用 NSAllocateObject/NSDeallocateObject</h4></li>
</ul>


<p>生成并持有一个Objective-C对象的时候，往往像下面一样使用NSObject的alloc接口函数。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">id</span> <span class="n">obj</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSObject</span> <span class="n">alloc</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>实际上，如果我们看了GNUstep 中关于 alloc 的代码就会明白，实际他是使用 NSAllocateObject 来生成并持有对象实例的。换言之，ARC有效的时候，NSAllocateObject函数的调用也是禁止的。如果使用，也会遇到下面的编译错误。</p>

<pre><code>error: ’NSAllocateObject’ is unavailable:
    not available in automatic reference counting mode
</code></pre>

<p>同样，对象释放时使用的 NSDeallocateObject 函数也不能使用。</p>

<ul>
<li><h4>不能使用 NSZone</h4></li>
</ul>


<p>NSZone 是什么？NSZone 是为了防止内存碎片而导入的一项措施。Zone 是内存管理的基本单元，系统中管理复数的Zone。系统根据对象的使用目的，尺寸，分配其所属的Zone区域。以提高对象的访问效率，避免不必要的内存碎片。但是，现在的运行时系统（用编译开关 __OBJC2__ 指定的情况下）是不支持Zone概念的。所以，不管ARC是否有效，都不能使用 NSZone。</p>

<ul>
<li><h4>不能明示调用dealloc</h4></li>
</ul>


<p>不管是否使用ARC，当对象被释放的时候，对象的dealloc函数被调用（就像是C++中对象的析构函数）。在该函数中，需要做一些内存释放的动作。比如，当对象中使用了malloc分配的C语言内存空间，那么dealloc中就需要像下面一样处理内存的释放。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="nf">dealloc</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>      <span class="n">free</span><span class="p">(</span><span class="n">buffer_</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>又或者是注册的delegate对象，观察者对象需要被删除的时候，也是在dealloc函数中动作。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="nf">dealloc</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>      <span class="p">[[</span><span class="n">NSNotificationCenter</span> <span class="n">defaultCenter</span><span class="p">]</span> <span class="nl">removeObserver:</span><span class="n">self</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果在ARC无效的时候，我们还要像下面一样，调用父类对象的dealloc函数。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="nf">dealloc</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>      <span class="p">[</span><span class="n">super</span> <span class="n">dealloc</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>但是当ARC有效的时候，[super dealloc];的调用已经被编译器自动执行，已经不需要我们明示调用了。如果你在代码中还这样写，难免遇到下面的错误。</p>

<pre><code>error: ARC forbids explicit message send of ’dealloc’
     [super dealloc];
      ^ ~~~~~~~
</code></pre>

<ul>
<li><h4>内存管理相关的函数必须遵循命名规则</h4></li>
</ul>


<p>在前面，我们知道如果是 alloc/new/copy/mutableCopy/init 开头的函数，需要将对象所有权返回给调用端。这条规则不管ARC是否有效都应该被遵守。只是 init 开头的函数比较特殊，他只在ARC下有要求，而且异常苛刻。</p>

<p>init 开始的函数只能返回id型，或者是该函数所属的类/父类的对象类型。基本上来说，init函数是针对alloc函数的返回值，做一些初始化处理，然后再将该对象返回。比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">id</span> <span class="n">obj</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSObject</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>再比如下面定义的函数就是不对的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="nf">initThisObject</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>需要是下面这样：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span> <span class="nf">initWithObject:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">obj</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>另外，下面名为 initialize 的函数比较特殊，编译器将把它过滤掉，不按上面的规则处理。</p>

<ul>
<li><h4>使用@autoreleasepool代替NSAutoreleasePool</h4></li>
</ul>


<p>在ARC之下，已经不能在代码中使用 NSAutoreleasePool，我们之前写 main.m 文件的时候，往往像下面这样写。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">NSAutoreleasePool</span> <span class="o">*</span> <span class="n">pool</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSAutoreleasePool</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>      <span class="kt">int</span> <span class="n">retVal</span> <span class="o">=</span> <span class="n">UIApplicationMain</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="nb">nil</span><span class="p">,</span> <span class="nb">nil</span><span class="p">);</span>
</span><span class='line'>    <span class="p">[</span><span class="n">pool</span> <span class="n">release</span><span class="p">];</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">retVal</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>而当ARC有效后，我们需要用@autoreleasepool代替NSAutoreleasePool。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>      <span class="err">@</span><span class="n">autoreleasepool</span> <span class="p">{</span>
</span><span class='line'>          <span class="k">return</span> <span class="n">UIApplicationMain</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="nb">nil</span><span class="p">,</span> <span class="n">NSStringFromClass</span><span class="p">([</span><span class="n">AppDelegate</span> <span class="n">class</span><span class="p">]));</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>当编译器看到 @autoreleasepool 定义的块后会自动生成 NSAutoreleasePool 对象，并将需要的对象放入 AutoReleasePool 中，当出方块的定义范围时，pool 中的对象将被释放。</p>

<ul>
<li><h4>Objective-C 对象不能作为C语言结构体（struct/union）的成员</h4></li>
</ul>


<p>当我们设置ARC有效，并在C语言的结构体中定义Objective-C的对象时，将出现类似下面的编译错误。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="n">Data</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">array</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>




<br>


<pre><code>error: ARC forbids Objective-C objs in structs or unions
     NSMutableArray *array;
                     ^
</code></pre>

<p>由于 ARC 是将内存管理的细节委托给编译器来做，所以说编译器必须要管理对象的生命周期。而LLVM 3.0中不存在对单纯C语言构造体成员的内存管理方法。如果单纯是栈对象，利用进出栈原理，可以简单地维护对象的生命周期；而结构体是不行的，简单地理解，结构体没有析构函数，编译器自身不能自动释放其内部的 Objective-C 对象。</p>

<p>当我们必须在C语言的结构体中放入 Objective-C 对象的时候，可以使用 void* 转型，或者使用 __unsafe_unretained 关键字。比如下面：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="n">Data</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">NSMutableArray</span> <span class="n">__unsafe_unretained</span> <span class="o">*</span><span class="n">array</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样一来，该内存信息不在编译器内存管理对象内，仅仅是使用而已，没有对象的持有权。当然，对象所有权的持有者需要明确的管理他与该结构体的交互，不要引起不必要的错误(关于这一点，可以参考<a href="http://www.yifeiyang.net/development-of-the-iphone-simply-1/">iPhone开发之深入浅出 (1) — ARC是什么</a> 一文，明白为什么 __unsafe_unretained 是危险的)。</p>

<ul>
<li><h4>[id]与[void*]之间需要明示cast</h4></li>
</ul>


<p>ARC 有效的时候，由于编译器帮我们做了内存管理的工作，所以我们不需要太担心。但是当与 ARC 管理以外的对象类型交互的时候，就需要特殊的转型关键字，来决定所有权的归属问题。</p>

<p>主要的转型关键字是:</p>

<table border="1">
<thead>
    <tr>
        <th>关键字</th>
        <th>解释</th>
    </tr>
</thead>
<tbody>
    <tr>
        <td>__bridge</td>
        <td>单纯的类型转换，没有进行所有权的转移</td>
    </tr>
    <tr>
        <td>__bridge_retained</td>
        <td>类型转换是伴随所有权传递，转换前后变量都持有对象的所有权</td>
    </tr>
    <tr>
        <td>__bridge_transfer</td>
        <td>类型转换伴随所有权转移，被转换变量将失去对象的所有权</td>
    </tr>
</tbody>
</table>


<p>当我们在 Core Foundation 对象类型与 Objective-C 对象类型之间切换的时候，需要把握下面的因素：</p>

<ul>
<li>明确被转换类型是否是 ARC 管理的对象</li>
<li>Core Foundation 对象类型不在 ARC 管理范畴内</li>
<li>Cocoa Framework::Foundation 对象类型（即一般使用到的Objectie-C对象类型）在 ARC 的管理范畴内</li>
<li>如果不在 ARC 管理范畴内的对象，那么要清楚 release 的责任应该是谁</li>
<li>各种对象的生命周期是怎样的</li>
</ul>


<h3>为什么iOS中没有GC</h3>

<p>我们已经知道ARC并不是GC（垃圾回收）了，那么，为什么iOS中不支持该机能呢？还特意搞出个ARC来。以下是我的分析：</p>

<ul>
<li>消耗CPU时间的处理尽量避免，以节约电池电量</li>
<li>GC执行的时候，会停掉运行时库；这是最大的心结</li>
<li>嵌入式设备本身内存就不是很大，如果GC不停的在后台运行，执行的频率会很高，严重影响性能</li>
<li>UI动画处理是iOS的一大卖点，而有了GC后可能会引起不必要的性能损失</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cocoa开发--事件监听]]></title>
    <link href="http://gbammc.github.io/blog/2013/11/05/cocoakai-fa-an-jian-shi-jian-jian-ting/"/>
    <updated>2013-11-05T21:45:00+08:00</updated>
    <id>http://gbammc.github.io/blog/2013/11/05/cocoakai-fa-an-jian-shi-jian-jian-ting</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p><a href="https://github.com/gbammc/FastSwitcher">FastSwitcher</a> 是我开发的第一个Mac应用,它实现的功能是通过按下全局的快捷键来切换应用,以此达到提高效率的目的。开发的原动力是因为最近发现我的手指在触摸板的使用过程中越来越痛了,而且不停的control+tab来切换应用觉得实在很烦很低效,但我经常需要切换的应用其实也就那么三四个,所以FastSwitcher就应运而生了。而在开发过程中所学到的Cocoa开发知识我想记录下来,所以这是第一篇 —— 事件监听。</p>

<!-- more -->


<hr />

<h1>全局快捷键</h1>

<p>全局快捷键,这是FastSwitcher中最重要的部分了,通过底层的Carbon.framework提供的API,FastSwitcher向系统注册全局的快捷键,当相应的按键被按下时,系统就可以立刻切换到对应的程序。当然我们可以它来做更多的事,下面就介绍如何注册一个全局快捷键。</p>

<h2>注册快捷键</h2>

<p>需要用Carbon框架,当然少不了添加依赖链接,然后在对应文件上加上引用<code>#import &lt;Carbon/Carbon.h&gt;</code></p>

<p>在方法中添加注册快捷键需要的变量:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">EventHotKeyRef</span> <span class="n">gMyHotKeyRef</span><span class="p">;</span>
</span><span class='line'><span class="n">EventHotKeyID</span> <span class="n">gMyHotKeyID</span><span class="p">;</span>
</span><span class='line'><span class="n">EventTypeSpec</span> <span class="n">eventType</span><span class="p">;</span>
</span><span class='line'><span class="n">eventType</span><span class="p">.</span><span class="n">eventClass</span> <span class="o">=</span> <span class="n">kEventClassKeyboard</span><span class="p">;</span>
</span><span class='line'><span class="n">eventType</span><span class="p">.</span><span class="n">eventKind</span> <span class="o">=</span> <span class="n">kEventHotKeyPressed</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这些变量将会保存我们快捷键的基本信息。通过对EventTypeSpec的eventClass和eventKind分别赋予kEventClassKeyboard和kEventHotKeyPressed两个值,来声明这个快捷键响应的是键盘按键事件。</p>

<p>接着我们注册一个实际的快捷键:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 快捷键的签名,实际类型为UInt32,所以用4个字符最好</span>
</span><span class='line'><span class="n">gMyHotKeyID</span><span class="p">.</span><span class="n">signature</span><span class="o">=</span><span class="err">&#39;</span><span class="n">hkid</span><span class="err">&#39;</span><span class="p">;</span>
</span><span class='line'><span class="c1">// 快捷键的id，处理多个全局快捷键时最好的标识</span>
</span><span class='line'><span class="n">gMyHotKeyID</span><span class="p">.</span><span class="kt">id</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="c1">// 通过这个函数向系统注册快捷键</span>
</span><span class='line'><span class="n">RegisterEventHotKey</span><span class="p">(</span><span class="mi">49</span><span class="p">,</span> <span class="n">cmdKey</span> <span class="o">+</span> <span class="n">optionKey</span><span class="p">,</span> <span class="n">gMyHotKeyID</span><span class="p">,</span> <span class="n">GetApplicationEventTarget</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gMyHotKeyRef</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>因为Carbon是用基于C语言写成的,所以RegisterEventHotKey()调用形式是C类型,第一个参数的数字,代表最终响应的键值,49代表空格键。第二个参数是控制键参数,可以选cmdKey, shiftKey, optionKey, controlKey或者是它们的组合,需要注意的是它们的连接使用‘+’号。当快捷键注册成功后,最后一个参数将会返回这个快捷键在系统中的引用。我们可以保存这个引用以便在以后再取消该快捷键。</p>

<h2>实现和注册回调函数</h2>

<p>回调函数原型为</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">OSStatus</span> <span class="nf">hotKeyHandler</span><span class="p">(</span><span class="n">EventHandlerCallRef</span> <span class="n">nextHandler</span><span class="p">,</span> <span class="n">EventRef</span> <span class="n">anEvent</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">userData</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>同样也是一个C类型函数，函数签名必须是上面的形式。示例实现代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">OSStatus</span> <span class="nf">hotKeyHandler</span><span class="p">(</span><span class="n">EventHandlerCallRef</span> <span class="n">nextHandler</span><span class="p">,</span> <span class="n">EventRef</span> <span class="n">anEvent</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">userData</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="n">AZAppDelegate</span> <span class="o">*</span><span class="p">)[</span><span class="n">NSApplication</span> <span class="n">sharedApplication</span><span class="p">]</span><span class="err">。</span><span class="n">delegate</span><span class="p">)</span><span class="err">。</span><span class="n">enableHotKey</span><span class="p">)</span> <span class="k">return</span> <span class="n">noErr</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">EventHotKeyID</span> <span class="n">hotKeyRef</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">GetEventParameter</span><span class="p">(</span><span class="n">anEvent</span><span class="p">,</span> <span class="n">kEventParamDirectObject</span><span class="p">,</span> <span class="n">typeEventHotKeyID</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">hotKeyRef</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hotKeyRef</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hotKeyId</span> <span class="o">=</span> <span class="n">hotKeyRef</span><span class="p">.</span><span class="kt">id</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">switch</span> <span class="p">(</span><span class="n">hotKeyId</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">case</span> <span class="mi">1</span><span class="o">:</span>
</span><span class='line'>            <span class="c1">// do something</span>
</span><span class='line'>            <span class="k">break</span><span class="p">;</span>
</span><span class='line'>        <span class="k">case</span> <span class="mi">2</span><span class="o">:</span>
</span><span class='line'>            <span class="c1">// do other thing</span>
</span><span class='line'>            <span class="k">break</span><span class="p">;</span>
</span><span class='line'>        <span class="k">default</span><span class="o">:</span>
</span><span class='line'>            <span class="k">break</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">noErr</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>处理多个全局快捷键的方式正如上面所示，通过判断快捷键的id值即可。最后我们在EventTypeSpec的赋值后面注册这个回调函数</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">EventHotKeyRef</span> <span class="n">gMyHotKeyRef</span><span class="p">;</span>
</span><span class='line'><span class="n">EventHotKeyID</span> <span class="n">gMyHotKeyID</span><span class="p">;</span>
</span><span class='line'><span class="n">EventTypeSpec</span> <span class="n">eventType</span><span class="p">;</span>
</span><span class='line'><span class="n">eventType</span><span class="p">.</span><span class="n">eventClass</span> <span class="o">=</span> <span class="n">kEventClassKeyboard</span><span class="p">;</span>
</span><span class='line'><span class="n">eventType</span><span class="p">.</span><span class="n">eventKind</span> <span class="o">=</span> <span class="n">kEventHotKeyPressed</span><span class="p">;</span>
</span><span class='line'><span class="n">InstallApplicationEventHandler</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hotKeyHandler</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eventType</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>至此，Mac系统就可以响应我们的快捷键了。</p>

<hr />

<h1>监听系统事件</h1>

<p>全局快捷键的响应必须由控制键参数和最终响应的键同时按下才能触发。如果我们要监听任意按键事件或鼠标事件呢？那么就需要<code>NSEvent</code>下的这两个方法了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 监听全局事件</span>
</span><span class='line'><span class="k">+</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">addGlobalMonitorForEventsMatchingMask:</span><span class="p">(</span><span class="n">NSEventMask</span><span class="p">)</span><span class="nv">mask</span> <span class="nf">handler:</span><span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="n">NSEvent</span><span class="o">*</span><span class="p">))</span><span class="nv">block</span><span class="p">;</span>
</span><span class='line'><span class="c1">// 监听本地事件</span>
</span><span class='line'><span class="k">+</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">addLocalMonitorForEventsMatchingMask:</span><span class="p">(</span><span class="n">NSEventMask</span><span class="p">)</span><span class="nv">mask</span> <span class="nf">handler:</span><span class="p">(</span><span class="n">NSEvent</span><span class="o">*</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="n">NSEvent</span><span class="o">*</span><span class="p">))</span><span class="nv">block</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这两个方法分别监听的是全局事件和本地事件。只要我们指定监听的<code>NSEventMask</code>类型，当对应事件触发时，我们就能够对其作进一步的处理。<code>NSEventMask</code>类型有十多种，这里就不全列出来了，不过基本覆盖了用户与系统所有的交互事件，在开发时选择合适的组合就好。</p>

<p>全局事件和本地事件的不同之处，在于全局事件我们不可以修改或阻止它继续向其它应用传送。但对于本地事件来说我们还是有能力这么做的，所以本地事件回调的block里我们需要返回一个NSEvent的变量。示例代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 全局</span>
</span><span class='line'><span class="p">[</span><span class="n">NSEvent</span> <span class="nl">addGlobalMonitorForEventsMatchingMask:</span><span class="n">NSFlagsChangedMask</span> <span class="nl">handler:</span><span class="o">^</span><span class="p">(</span><span class="n">NSEvent</span> <span class="o">*</span><span class="n">event</span><span class="p">){</span>
</span><span class='line'>    <span class="n">NSUInteger</span> <span class="n">flags</span> <span class="o">=</span> <span class="p">[</span><span class="n">event</span> <span class="n">modifierFlags</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">NSDeviceIndependentModifierFlagsMask</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">==</span> <span class="n">NSCommandKeyMask</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// handle it</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}];</span>
</span><span class='line'><span class="c1">// 本地</span>
</span><span class='line'><span class="p">[</span><span class="n">NSEvent</span> <span class="nl">addLocalMonitorForEventsMatchingMask:</span><span class="n">NSFlagsChangedMask</span> <span class="nl">handler:</span><span class="o">^</span><span class="p">(</span><span class="n">NSEvent</span> <span class="o">*</span><span class="n">event</span><span class="p">){</span>
</span><span class='line'>    <span class="n">NSUInteger</span> <span class="n">flags</span> <span class="o">=</span> <span class="p">[</span><span class="n">event</span> <span class="n">modifierFlags</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">NSDeviceIndependentModifierFlagsMask</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">==</span> <span class="n">NSCommandKeyMask</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// handle it</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">event</span><span class="p">;</span>
</span><span class='line'><span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>


<hr />

<h1>让控件响应特定事件</h1>

<p>上面的方法已经很好很强大了，但如果我们要令特定控件响应某些事件呢？比如让NSTextField在按下esc键后清除所有内容，当鼠标移动到图片上时让其高亮，这样我们就不能简单地使用以上的方法了。但对于这种情况我们可以用<strong>NSResponder</strong>的方法处理。</p>

<p><strong>NSResponder</strong>中定义了很多事件响应方法，如:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">rightMouseDown:</span><span class="p">(</span><span class="n">NSEvent</span> <span class="o">*</span><span class="p">)</span><span class="nv">theEvent</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">otherMouseDown:</span><span class="p">(</span><span class="n">NSEvent</span> <span class="o">*</span><span class="p">)</span><span class="nv">theEvent</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">mouseUp:</span><span class="p">(</span><span class="n">NSEvent</span> <span class="o">*</span><span class="p">)</span><span class="nv">theEvent</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">rightMouseUp:</span><span class="p">(</span><span class="n">NSEvent</span> <span class="o">*</span><span class="p">)</span><span class="nv">theEvent</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">otherMouseUp:</span><span class="p">(</span><span class="n">NSEvent</span> <span class="o">*</span><span class="p">)</span><span class="nv">theEvent</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">mouseMoved:</span><span class="p">(</span><span class="n">NSEvent</span> <span class="o">*</span><span class="p">)</span><span class="nv">theEvent</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">mouseDragged:</span><span class="p">(</span><span class="n">NSEvent</span> <span class="o">*</span><span class="p">)</span><span class="nv">theEvent</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">scrollWheel:</span><span class="p">(</span><span class="n">NSEvent</span> <span class="o">*</span><span class="p">)</span><span class="nv">theEvent</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">rightMouseDragged:</span><span class="p">(</span><span class="n">NSEvent</span> <span class="o">*</span><span class="p">)</span><span class="nv">theEvent</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">otherMouseDragged:</span><span class="p">(</span><span class="n">NSEvent</span> <span class="o">*</span><span class="p">)</span><span class="nv">theEvent</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">mouseEntered:</span><span class="p">(</span><span class="n">NSEvent</span> <span class="o">*</span><span class="p">)</span><span class="nv">theEvent</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">mouseExited:</span><span class="p">(</span><span class="n">NSEvent</span> <span class="o">*</span><span class="p">)</span><span class="nv">theEvent</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">keyDown:</span><span class="p">(</span><span class="n">NSEvent</span> <span class="o">*</span><span class="p">)</span><span class="nv">theEvent</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">keyUp:</span><span class="p">(</span><span class="n">NSEvent</span> <span class="o">*</span><span class="p">)</span><span class="nv">theEvent</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">flagsChanged:</span><span class="p">(</span><span class="n">NSEvent</span> <span class="o">*</span><span class="p">)</span><span class="nv">theEvent</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">tabletPoint:</span><span class="p">(</span><span class="n">NSEvent</span> <span class="o">*</span><span class="p">)</span><span class="nv">theEvent</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">tabletProximity:</span><span class="p">(</span><span class="n">NSEvent</span> <span class="o">*</span><span class="p">)</span><span class="nv">theEvent</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">cursorUpdate:</span><span class="p">(</span><span class="n">NSEvent</span> <span class="o">*</span><span class="p">)</span><span class="nv">event</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过定制这些方法，就可以让控件的表现得更独特或让用户感到更便捷，下面是按下<code>cmd + W</code>关闭窗口事件的示例代码:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">keyDown:</span><span class="p">(</span><span class="n">NSEvent</span> <span class="o">*</span><span class="p">)</span><span class="nv">theEvent</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">NSString</span> <span class="o">*</span><span class="n">key</span> <span class="o">=</span> <span class="p">[</span><span class="n">theEvent</span> <span class="n">charactersIgnoringModifiers</span><span class="p">];</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(([</span><span class="n">theEvent</span> <span class="n">modifierFlags</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">NSCommandKeyMask</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">[</span><span class="n">key</span> <span class="nl">isEqualToString:</span><span class="s">@&quot;w&quot;</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>        <span class="p">[</span><span class="n">self</span> <span class="n">close</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="p">[</span><span class="n">super</span> <span class="nl">keyDown:</span><span class="n">theEvent</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<hr />

<h1>PS：</h1>

<p>经常在论坛上看到有人说Mac开发很难，我想可能是因为在Mac开发方面的中文资料太少了，在开发FastSwitcher的过程中我也碰到了不少问题，不过基本上都是靠苹果的英文文档，StackOverflow或Google搜到的国外博客的帮助下解决的。现在OS X免费了，加上Mac产品优秀的用户体验(可能有些装X，但谁用谁知道)，我想以后Mac的用户会越来越多，市场也会越来越大，真心希望Mac开发的阵营也能更大~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS的多线程原理、分类与应用]]></title>
    <link href="http://gbammc.github.io/blog/2013/10/06/iosde-duo-xian-cheng-fen-lei-yu-ying-yong/"/>
    <updated>2013-10-06T23:58:00+08:00</updated>
    <id>http://gbammc.github.io/blog/2013/10/06/iosde-duo-xian-cheng-fen-lei-yu-ying-yong</id>
    <content type="html"><![CDATA[<p>今天查资料才发现，iOS中的线程使用不是无限制的，官方文档给出的<a href="https://developer.apple.com/library/mac/documentation/cocoa/conceptual/Multithreading/CreatingThreads/CreatingThreads.html">资料</a>显示iOS下的主线程堆栈大小是1M，第二个线程开始都是512KB，并且该值不能通过编译器开关或线程API函数来更改。另外只有主线程有直接修改UI的能力。所以也学习并总结下iOS的多线程编程来加深下吧。</p>

<!-- more -->


<ul>
<li><a href="#runloop">关于RunLoopg</a></li>
<li><a href="#nsthread">NSThread</a></li>
<li><a href="#nsoperation">NSOperationQueue和NSOperation</a></li>
<li><a href="#gcd">GCD</a></li>
<li><a href="#compare">NSOperationQueue与GCD的对比</a></li>
</ul>


<hr />

<h2><span id="runloop">关于RunLoop</span></h2>

<p>首先关于RunLoop，iOS中的RunLoop准确的说是线程中的循环。首先循环体的开始需要检测是否有需要处理的事件，如果有则去处理，如果没有则进入睡眠以节省CPU时间。 所以重点便是这个需要处理的事件，在RunLoop中，需要处理的事件分两类，一种是输入源，一种是定时器。定时器好理解，就是那些需要定时执行的操作;输入源分三类：performSelector源，基于端口（Mach port）的源，以及自定义的源。而RunLoop在每一次循环的开始便去检查这些事件源是否有需要处理的数据，有的话则去处理。</p>

<p>系统会自动为应用程序的主线程生成一个与之对应的 run loop 来处理其消息循环。在触摸 UIView 时之所以能够激发 touchesBegan/touchesMoved 等等函数被调用，就是因为应用程序的主线程在 UIApplicationMain 里面有这样一个 run loop 在分发 input 或 timer 事件。</p>

<p>而每一个线程都有其对应的RunLoop，但是默认非主线程的RunLoop是没有运行的，需要为RunLoop添加至少一个事件源，然后去run它。一般情况下我们是没有必要去启用线程的RunLoop的，除非你在一个单独的线程中需要长久的检测某个事件。</p>

<hr />

<h2><span id="multi-thread">多线程编程</span></h2>

<p>iOS中的多线程编程主要分以下三类：1.NSThread;2.NSOperation/NSOperationQueue;3.GCD。后两者其实都是对NSThreads的调用再进行一次封装，以便开发人员更容易使用iOS中的多线程编程。而对于NSOperation/NSOperationQueue和GCD的比较，支持者们意见不太统一，应该适时选择合适的。这里也附上StackOverflow上的<a href="http://stackoverflow.com/questions/10373331/nsoperation-vs-grand-central-dispatch">讨论</a>(本文后面也有列出大概原因)情况。</p>

<h3><span id="nsthread">NSThread</span></h3>

<ul>
<li>优点：NSThread比其他两个轻量级</li>
<li>缺点：需要自己管理线程的生命周期，线程同步。线程同步对数据的加锁会有一定的系统开销</li>
</ul>


<p><strong>NSThread的使用</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">initWithTarget:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">target</span> <span class="nf">selector:</span><span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">selector</span> <span class="nf">object:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">argument</span>
</span><span class='line'><span class="k">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">detachNewThreadSelector:</span><span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">aSelector</span> <span class="nf">toTarget:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">aTarget</span> <span class="nf">withObject:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">anArgument</span>
</span></code></pre></td></tr></table></div></figure>


<p>第一个是实例方法，第二个是类方法</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 类方法</span>
</span><span class='line'><span class="p">[</span><span class="n">NSThread</span> <span class="nl">detachNewThreadSelector:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">doSomething:</span><span class="p">)</span> <span class="nl">toTarget:</span><span class="n">self</span> <span class="nl">withObject:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 实例方法的声明</span>
</span><span class='line'><span class="n">NSThread</span><span class="o">*</span> <span class="n">myThread</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSThread</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithTarget:</span><span class="n">self</span>
</span><span class='line'>                                        <span class="nl">selector:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">doSomething:</span><span class="p">)</span>
</span><span class='line'>                                        <span class="nl">object:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'><span class="c1">// 实例方法的调用</span>
</span><span class='line'><span class="p">[</span><span class="n">myThread</span> <span class="n">start</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>这两种方式的区别是：前一种一调用就会立即创建一个线程来做事情;而后一种虽然你alloc了也init了，但是要直到我们手动调用 <code>start</code> 启动线程时才会真正去创建线程。这种延迟实现思想在很多跟资源相关的地方都有用到。后一种方式我们还可以在启动线程之前，对线程进行配置，比如设置stack大小，线程优先级。</p>

<p>还有一种间接的方式，更加方便，我们甚至不需要显式编写NSThread相关代码。那就是利用NSObject的类方法 <code>performSelectorInBackground:withObject:</code> 来创建一个线程：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[</span><span class="n">myObj</span> <span class="nl">performSelectorInBackground:</span><span class="k">@selector</span><span class="p">(</span><span class="n">myThreadMainMethod</span><span class="p">)</span> <span class="nl">withObject:</span><span class="nb">nil</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>其效果与NSThread的 <code>detachNewThreadSelector:toTarget:withObject:</code> 是一样的</p>

<p><strong>线程同步</strong></p>

<p>线程的同步方法跟其他系统下类似，我们可以用原子操作，可以用mutex，lock等。</p>

<p>iOS的原子操作函数是以OSAtomic开头的，比如：OSAtomicAdd32, OSAtomicOr32等等。这些函数可以直接使用，因为它们是原子操作。</p>

<p>iOS中的mutex对应的是NSLock，它遵循 NSLooking协议，我们可以使用lock, tryLock, lockBeforeData:来加锁，用unLock来解锁。使用示例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">BOOL</span> <span class="n">moreToDo</span> <span class="o">=</span> <span class="n">YES</span><span class="p">;</span>
</span><span class='line'><span class="n">NSLock</span> <span class="o">*</span><span class="n">theLock</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSLock</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="k">while</span> <span class="p">(</span><span class="n">moreToDo</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="cm">/* Do another increment of calculation */</span>
</span><span class='line'>    <span class="cm">/* until there’s no more to do. */</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">([</span><span class="n">theLock</span> <span class="n">tryLock</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>        <span class="cm">/* Update display used by all threads. */</span>
</span><span class='line'>        <span class="p">[</span><span class="n">theLock</span> <span class="n">unlock</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们可以使用指令 @synchronized 来简化 NSLock的使用，这样我们就不必显示编写创建NSLock,加锁并解锁相关代码。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">myMethod:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">anObj</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">@synchronized</span><span class="p">(</span><span class="n">anObj</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="c1">// Everything between the braces is protected by the @synchronized directive.</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>还有其他的一些锁对象，比如：循环锁NSRecursiveLock，条件锁NSConditionLock，分布式锁NSDistributedLock等等，在这里就不一一介绍了。</p>

<p><strong>用NSCodition同步执行的顺序</strong></p>

<p>NSCodition是一种特殊类型的锁，我们可以用它来同步操作执行的顺序。它与mutex的区别在于更加精准，等待某个NSCondtion的线程一直被lock，直到其他线程给那个condition发送了信号。下面我们来看使用示例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 某个线程等待着事情去做，而有没有事情做是由其他线程通知它的</span>
</span><span class='line'><span class="p">[</span><span class="n">cocoaCondition</span> <span class="n">lock</span><span class="p">];</span>
</span><span class='line'><span class="k">while</span> <span class="p">(</span><span class="n">timeToDoWork</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">[</span><span class="n">cocoaCondition</span> <span class="n">wait</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="n">timeToDoWork</span><span class="o">--</span><span class="p">;</span>
</span><span class='line'><span class="c1">// Do real work here.</span>
</span><span class='line'>
</span><span class='line'><span class="p">[</span><span class="n">cocoaCondition</span> <span class="n">unlock</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//其他线程发送信号通知上面的线程可以做事情了：</span>
</span><span class='line'><span class="p">[</span><span class="n">cocoaCondition</span> <span class="n">lock</span><span class="p">];</span>
</span><span class='line'><span class="n">timeToDoWork</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'><span class="p">[</span><span class="n">cocoaCondition</span> <span class="n">signal</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">cocoaCondition</span> <span class="n">unlock</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>线程间通信</strong></p>

<p>线程在运行过程中，可能需要与其它线程进行通信。我们可以使用 NSObject 中的一些方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 在应用程序主线程中做事情：</span>
</span><span class='line'><span class="nl">performSelectorOnMainThread:withObject:waitUntilDone:</span>
</span><span class='line'><span class="nl">performSelectorOnMainThread:withObject:waitUntilDone:modes:</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 在指定线程中做事情：</span>
</span><span class='line'><span class="nl">performSelector:onThread:withObject:waitUntilDone:</span>
</span><span class='line'><span class="nl">performSelector:onThread:withObject:waitUntilDone:modes:</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 在当前线程中做事情：</span>
</span><span class='line'><span class="nl">performSelector:withObject:afterDelay:</span>
</span><span class='line'><span class="nl">performSelector:withObject:afterDelay:inModes:</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 取消发送给当前线程的某个消息</span>
</span><span class='line'><span class="nl">cancelPreviousPerformRequestsWithTarget:</span>
</span><span class='line'><span class="nl">cancelPreviousPerformRequestsWithTarget:selector:object:</span>
</span></code></pre></td></tr></table></div></figure>


<p>如在我们在某个线程中下载数据，下载完成之后要通知主线程中更新界面等等，可以使用如下接口：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">callMainThreadMethod</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">NSAutoreleasePool</span> <span class="o">*</span><span class="n">pool</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSAutoreleasePool</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="c1">// to do something in your thread job</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'>    <span class="p">[</span><span class="n">self</span> <span class="nl">performSelectorOnMainThread:</span><span class="k">@selector</span><span class="p">(</span><span class="n">updateUI</span><span class="p">)</span> <span class="nl">withObject:</span><span class="nb">nil</span> <span class="nl">waitUntilDone:</span><span class="n">NO</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">pool</span> <span class="n">release</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>隐式调用</strong></p>

<p>用NSObject的类方法<code>performSelectorInBackground:withObject:</code>创建一个线程：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[</span><span class="n">myObj</span> <span class="nl">performSelectorInBackground:</span><span class="k">@selector</span><span class="p">(</span><span class="n">doSomething</span><span class="p">)</span> <span class="nl">withObject:</span><span class="nb">nil</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<hr />

<h3><span id="nsoperation">NSOperationQueue和NSOperation</span></h3>

<p>多线程编程是防止主线程堵塞，增加运行效率等等的最佳方法。而原始的多线程方法存在很多的毛病，包括线程锁死等。在Cocoa中，Apple提供了NSOperation这个类，提供了一个优秀的多线程编程方法。</p>

<p>NSOperationQueue会建立一个线程管理器，每个加入到线程operation会有序的执行。</p>

<p>用NSOperationQueue的过程：</p>

<ol>
<li>建立一个NSOperationQueue的对象</li>
<li>建立一个NSOperation的对象</li>
<li>将operation加入到NSOperationQueue中</li>
<li>release掉operation</li>
</ol>


<p>本次介绍NSOperation的子集，简易方法的NSInvocationOperation：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@implementation</span> <span class="nc">MyCustomClass</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">launchTaskWithData:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">data</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">//创建一个NSInvocationOperation对象，并初始化到方法</span>
</span><span class='line'>    <span class="c1">//在这里，selector参数后的值是你想在另外一个线程中运行的方法（函数，Method）</span>
</span><span class='line'>    <span class="c1">//在这里，object后的值是想传递给前面方法的数据</span>
</span><span class='line'>    <span class="n">NSInvocationOperation</span><span class="o">*</span> <span class="n">theOp</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSInvocationOperation</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithTarget:</span><span class="n">self</span>
</span><span class='line'>                    <span class="nl">selector:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">myTaskMethod:</span><span class="p">)</span> <span class="nl">object:</span><span class="n">data</span><span class="p">];</span>
</span><span class='line'>    <span class="c1">// 下面将我们建立的操作“Operation”加入到本地程序的共享队列中（加入后方法就会立刻被执行）</span>
</span><span class='line'>    <span class="c1">// 更多的时候是由我们自己建立“操作”队列</span>
</span><span class='line'>    <span class="p">[[</span><span class="n">MyAppDelegate</span> <span class="n">sharedOperationQueue</span><span class="p">]</span> <span class="nl">addOperation:</span><span class="n">theOp</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// 这个是真正运行在另外一个线程的“方法”</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">myTaskMethod:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">data</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">// Perform the task.</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>一个NSOperationQueue操作队列，就相当于一个线程管理器，而非一个线程。因为你可以设置这个线程管理器内可以并行运行的的线程数量等等。下面是建立并初始化一个操作队列：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@interface</span> <span class="nc">MyViewController</span> : <span class="nc">UIViewController</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">NSOperationQueue</span> <span class="o">*</span><span class="n">operationQueue</span><span class="p">;</span>
</span><span class='line'>    <span class="c1">//在头文件中声明该队列</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">MyViewController</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">init</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">operationQueue</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSOperationQueue</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span> <span class="c1">//初始化操作队列</span>
</span><span class='line'>        <span class="p">[</span><span class="n">operationQueue</span> <span class="nl">setMaxConcurrentOperationCount:</span><span class="mi">1</span><span class="p">];</span>
</span><span class='line'>        <span class="c1">//在这里限定了该队列只同时运行一个线程</span>
</span><span class='line'>        <span class="c1">//这个队列已经可以使用了</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">dealloc</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="n">operationQueue</span> <span class="n">release</span><span class="p">];</span>
</span><span class='line'>    <span class="c1">//正如Alan经常说的，我们是程序的好公民，需要释放内存！</span>
</span><span class='line'>    <span class="p">[</span><span class="n">super</span> <span class="n">dealloc</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<hr />

<h3><span id="gcd">GCD</span></h3>

<p>GCD是一个替代诸如NSThread, NSOperationQueue, NSInvocationOperation等技术的很高效和强大的技术，它看起来象就其它语言的闭包(Closure)一样，但苹果把它叫做blocks。</p>

<h4>GCD的定义</h4>

<p>简单GCD的定义有点象函数指针，差别是用 ^ 替代了函数指针的 * 号，如下所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 申明变量 </span>
</span><span class='line'> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">(</span><span class="o">^</span><span class="n">loggerBlock</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
</span><span class='line'> <span class="c1">// 定义 </span>
</span><span class='line'> <span class="n">loggerBlock</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>      <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Hello world&quot;</span><span class="p">);</span>
</span><span class='line'> <span class="p">};</span>
</span><span class='line'> <span class="c1">// 调用 </span>
</span><span class='line'> <span class="n">loggerBlock</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>但是大多数时候，我们通常使用内联的方式来定义它，即将它的程序块写在调用的函数里面，例如这样：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>     <span class="c1">// something </span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>从上面大家可以看出，block有如下特点：</p>

<p>程序块可以在代码中以内联的方式来定义。
程序块可以访问在创建它的范围内的可用的变量。</p>

<p>系统提供的dispatch方法</p>

<p>为了方便地使用GCD，苹果提供了一些方法方便我们将block放在主线程 或 后台线程执行，或者延后执行。使用的例子如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">//  后台执行： </span>
</span><span class='line'> <span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>      <span class="c1">// something </span>
</span><span class='line'> <span class="p">});</span>
</span><span class='line'> <span class="c1">// 主线程执行： </span>
</span><span class='line'> <span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>      <span class="c1">// something </span>
</span><span class='line'> <span class="p">});</span>
</span><span class='line'> <span class="c1">// 一次性执行： </span>
</span><span class='line'> <span class="k">static</span> <span class="n">dispatch_once_t</span> <span class="n">onceToken</span><span class="p">;</span>
</span><span class='line'> <span class="n">dispatch_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">onceToken</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>     <span class="c1">// code to be executed once </span>
</span><span class='line'> <span class="p">});</span>
</span><span class='line'> <span class="c1">// 延迟2秒执行： </span>
</span><span class='line'> <span class="kt">double</span> <span class="n">delayInSeconds</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">;</span>
</span><span class='line'> <span class="n">dispatch_time_t</span> <span class="n">popTime</span> <span class="o">=</span> <span class="n">dispatch_time</span><span class="p">(</span><span class="n">DISPATCH_TIME_NOW</span><span class="p">,</span> <span class="n">delayInSeconds</span> <span class="o">*</span> <span class="n">NSEC_PER_SEC</span><span class="p">);</span>
</span><span class='line'> <span class="n">dispatch_after</span><span class="p">(</span><span class="n">popTime</span><span class="p">,</span> <span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
</span><span class='line'>     <span class="c1">// code to be executed on the main queue after delay </span>
</span><span class='line'> <span class="p">});</span>
</span><span class='line'><span class="c1">// dispatch_queue_t 也可以自己定义，如要要自定义queue，可以用dispatch_queue_create方法，示例如下：</span>
</span><span class='line'>
</span><span class='line'><span class="n">dispatch_queue_t</span> <span class="n">urls_queue</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">(</span><span class="s">&quot;blog.devtang.com&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'><span class="n">dispatch_async</span><span class="p">(</span><span class="n">urls_queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>     <span class="c1">// your code </span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'><span class="n">dispatch_release</span><span class="p">(</span><span class="n">urls_queue</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>后台运行</strong></p>

<p>GCD的另一个用处是可以让程序在后台较长久的运行。在没有使用GCD时，当app被按home键退出后，app仅有最多5秒钟的时候做一些保存或清理资源的工作。但是在使用GCD后，app最多有10分钟的时间在后台长久运行。这个时间可以用来做清理本地缓存，发送统计数据等工作。</p>

<p>另外，GCD还有一些高级用法，例如让后台2个线程并行执行，然后等2个线程都结束后，再汇总执行结果。这个可以用dispatch_group, dispatch_group_async 和 dispatch_group_notify来实现，示例如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">dispatch_group_t</span> <span class="n">group</span> <span class="o">=</span> <span class="n">dispatch_group_create</span><span class="p">();</span>
</span><span class='line'><span class="n">dispatch_group_async</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>      <span class="c1">// 并行执行的线程一 </span>
</span><span class='line'> <span class="p">});</span>
</span><span class='line'> <span class="n">dispatch_group_async</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>      <span class="c1">// 并行执行的线程二 </span>
</span><span class='line'> <span class="p">});</span>
</span><span class='line'> <span class="n">dispatch_group_notify</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>      <span class="c1">// 汇总结果 </span>
</span><span class='line'> <span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>让程序在后台长久运行的示例代码如下:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// AppDelegate.h文件 </span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">assign</span><span class="p">,</span> <span class="n">nonatomic</span><span class="p">)</span> <span class="n">UIBackgroundTaskIdentifier</span> <span class="n">backgroundUpdateTask</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// AppDelegate.m文件 </span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">applicationDidEnterBackground:</span><span class="p">(</span><span class="n">UIApplication</span> <span class="o">*</span><span class="p">)</span><span class="nv">application</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="n">self</span> <span class="n">beingBackgroundUpdateTask</span><span class="p">];</span>
</span><span class='line'>    <span class="c1">// 在这里加上你需要长久运行的代码 </span>
</span><span class='line'>    <span class="p">[</span><span class="n">self</span> <span class="n">endBackgroundUpdateTask</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">beingBackgroundUpdateTask</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">self</span><span class="p">.</span><span class="n">backgroundUpdateTask</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIApplication</span> <span class="n">sharedApplication</span><span class="p">]</span> <span class="nl">beginBackgroundTaskWithExpirationHandler:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="p">[</span><span class="n">self</span> <span class="n">endBackgroundUpdateTask</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">endBackgroundUpdateTask</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="p">[[</span><span class="n">UIApplication</span> <span class="n">sharedApplication</span><span class="p">]</span> <span class="nl">endBackgroundTask:</span> <span class="n">self</span><span class="p">.</span><span class="n">backgroundUpdateTask</span><span class="p">];</span>
</span><span class='line'>    <span class="n">self</span><span class="p">.</span><span class="n">backgroundUpdateTask</span> <span class="o">=</span> <span class="n">UIBackgroundTaskInvalid</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2><span id="compare">NSOperationQueue与GCD的对比</span></h2>

<p>对于NSOperationQueue和GCD应该用哪个，一般来说可以用编程界比较通用的原则来决定：</p>

<pre><code>Always use the highest-level abstraction available to you, and drop down to lower-level abstractions when measurement shows that they are needed.
</code></pre>

<p>简意是：尽可能用更高级抽象的方法。但前面提到的StackOverflow里的讨论里却分别说出了两者的优缺点：</p>

<p><strong>NSOperation好处：</strong></p>

<ul>
<li>很容易设置两个NSOperation之间的依赖来让某一个操作在上一个操作完成后才执行</li>
<li>方便设置在同一时间运行的操作个数</li>
<li><p>您可以创建操作,支持在第一时间被取消</p></li>
<li><p>bandwidth-constrained queues that only run N operations at a time</p></li>
<li>establishing dependencies between operations</li>
<li>you can create operations that support being cancelled in the first place</li>
</ul>


<p><strong>GCD好处：</strong></p>

<ul>
<li>NSOperation对象在创建或释放过程中会消耗明显的CPU资源</li>
<li><p>使用Blocks后代码比使用NSOperation更简洁</p></li>
<li><p>The NSOperation object allocation and deallocation process took a significant amount of CPU resources when dealing with small and frequent actions, like rendering an OpenGL ES frame to the screen. GCD blocks completely eliminated that overhead, leading to significant performance improvements.</p></li>
<li>code is cleaner when using blocks than NSOperations.</li>
</ul>


<p>当然，具体使用哪一个还是要看你的使用场合了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TheOS越狱开发]]></title>
    <link href="http://gbammc.github.io/blog/2013/10/04/theosyue-yu-kai-fa/"/>
    <updated>2013-10-04T22:45:00+08:00</updated>
    <id>http://gbammc.github.io/blog/2013/10/04/theosyue-yu-kai-fa</id>
    <content type="html"><![CDATA[<p>因为最近对越狱开发感兴趣起来，所以果断利用Google去找资料，结果发现相关的东西却是少之又少，于是想如果我能在这个摸爬过程中学到一些东西的话，就都把它整理post出来，让更多有兴趣的人也能参与当中。</p>

<p>而对于越狱开发，我是这么认为的：为了利用iOS系统私有的API，你不得不去挖掘系统底层的东西，在这个过程中，你又会加深对整个系统的了解，从而将自己的开发水平提升一个档次。虽然苹果不会鼓励这样做，不过也是一条有乐趣的学习之道吧。</p>

<!-- more -->


<hr />

<h3>1.TheOS环境搭建</h3>

<p><a href="http://brandontreb.com/beginning-jailbroken-ios-development-your-first-tweak">http://brandontreb.com/beginning-jailbroken-ios-development-your-first-tweak</a>
这是国外很全面的TheOS环境搭建和打包工具安装以及一个简单TheOS程序示例，英语比较好的同学可以参照这一篇。</p>

<p>安装theos主要步骤如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span><span class="nb">export </span><span class="nv">THEOS</span><span class="o">=</span>/opt/theos
</span><span class='line'><span class="nv">$ </span>git clone git://github.com/DHowett/theos.git <span class="nv">$THEOS</span>
</span><span class='line'><span class="nv">$ </span>sudo chmod -Rf 777 <span class="nv">$THEOS</span>
</span><span class='line'><span class="nv">$ </span>curl -s http://dl.dropbox.com/u/3157793/ldid &gt; <span class="nv">$THEOS</span>/bin/ldid
</span><span class='line'><span class="nv">$ </span>chmod 777 <span class="nv">$THEOS</span>/bin/ldid
</span><span class='line'><span class="nv">$ </span><span class="nb">cd</span> <span class="nv">$THEOS</span>/include/IOSurface
</span><span class='line'><span class="nv">$ </span>sudo curl -O -k https://raw.github.com/javacom/toolchain4/master/Projects/IOSurfaceAPI.h
</span></code></pre></td></tr></table></div></figure>


<p>这样就完成TheOS的安装了。</p>

<p>另外还需要下载一个class-dump工具包，用于导出苹果库中的私有头文件:
<a href="https://github.com/nygard/class-dump">https://github.com/nygard/class-dump</a>
，或者也可以直接使用rpetrich大神的<a href="https://github.com/rpetrich/iphoneheaders">头文件库</a>。把得到的头文件解压并放到$THEOS/include中即可。</p>

<hr />

<h3>2.打包工具</h3>

<h4>1)安装Macports</h4>

<p>如果已经安装了那么可以忽略这一步，查看是否已经安装可以输入如下指令：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>port version
</span></code></pre></td></tr></table></div></figure>


<p>官方下载传送门：<a href="http://www.macports.org/install.php">http://www.macports.org/install.php</a></p>

<h4>2)安装dpkg</h4>

<p>安装dpkg的命令</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>sudo port install dpkg
</span></code></pre></td></tr></table></div></figure>


<hr />

<h3>3.TheOS生成的Makefile文件剖析</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>include theos/makefiles/common.mk
</span></code></pre></td></tr></table></div></figure>


<p>告诉TheOS在编译脚本仲包括共同的make命令，避免做重复的make编译工作</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">TWEAK_NAME</span> <span class="o">=</span> HelloWorld
</span></code></pre></td></tr></table></div></figure>


<p>我们要变异的应用程序的名称。Makefile将会用这个常量在内部做一些事情。除非你的应用程序改名称，否则不要修改这个值。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="o">[</span>TWEAK_NAME<span class="o">]</span><span class="nv">_FILES</span> <span class="o">=</span> Tweak.xm
</span></code></pre></td></tr></table></div></figure>


<p>这里是需要编译的文件列表。注意：不要把头文件添加到这里。如果你要添加一个新的.m或者.mm文件到项目中，确保在这里添加新的文件名称，否则将不会建立编译连接。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="o">[</span>TWEAK_NAME<span class="o">]</span><span class="nv">_FRAMEWORKS</span> <span class="o">=</span> UIKit Foundation
</span></code></pre></td></tr></table></div></figure>


<p>这里包括你想用到框架的名称</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>include <span class="k">$(</span>THEOS_MAKE_PATH<span class="k">)</span>/application.mk
</span></code></pre></td></tr></table></div></figure>


<p>更多默认的用于帮助TheOS建立项目</p>

<hr />

<h3>4.第一个HelloWorld后台程序</h3>

<p>在终端中输入：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span><span class="nb">export </span><span class="nv">THEOS</span><span class="o">=</span>/opt/theos/
</span><span class='line'><span class="nv">$ </span><span class="nb">export </span><span class="nv">SDKVERSION</span><span class="o">=</span>5.1            // sdk版本号
</span><span class='line'><span class="nv">$ $THEOS</span>/bin/nic.pl               // 执行TheOS
</span><span class='line'>NIC 2.0 - New Instance Creator
</span><span class='line'>------------------------------
</span><span class='line'>  <span class="o">[</span>1.<span class="o">]</span> iphone/application
</span><span class='line'>  <span class="o">[</span>2.<span class="o">]</span> iphone/cydget
</span><span class='line'>  <span class="o">[</span>3.<span class="o">]</span> iphone/dashboardx_widget
</span><span class='line'>  <span class="o">[</span>4.<span class="o">]</span> iphone/framework
</span><span class='line'>  <span class="o">[</span>5.<span class="o">]</span> iphone/library
</span><span class='line'>  <span class="o">[</span>6.<span class="o">]</span> iphone/notification_center_widget
</span><span class='line'>  <span class="o">[</span>7.<span class="o">]</span> iphone/preference_bundle
</span><span class='line'>  <span class="o">[</span>8.<span class="o">]</span> iphone/sbsettingstoggle
</span><span class='line'>  <span class="o">[</span>9.<span class="o">]</span> iphone/tool
</span><span class='line'>  <span class="o">[</span>10.<span class="o">]</span> iphone/tweak
</span><span class='line'>Choose a Template <span class="o">(</span>required<span class="o">)</span>: 10
</span><span class='line'>Project Name <span class="o">(</span>required<span class="o">)</span>: HelloWorld
</span><span class='line'>Package Name <span class="o">[</span>com.yourcompany.helloworld<span class="o">]</span>:
</span><span class='line'>Author/Maintainer Name <span class="o">[</span>Alvin<span class="o">]</span>:
</span><span class='line'><span class="o">[</span>iphone/tweak<span class="o">]</span> MobileSubstrate Bundle filter    <span class="o">[</span>com.apple.springboard<span class="o">]</span>:
</span><span class='line'>Instantiating iphone/tweak in helloworld/...
</span><span class='line'>Done.
</span></code></pre></td></tr></table></div></figure>


<p>我们创建一个后台程序，要做的是当系统开机时候弹出HelloWorld字样的Alert框。</p>

<p>打开Tweak.xm文件，清空后添加以下代码</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#import &lt;UIKit/UIKit.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">%</span><span class="n">hook</span> <span class="n">SpringBoard</span>
</span><span class='line'>
</span><span class='line'><span class="o">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">applicationDidFinishLaunching:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="n">application</span> <span class="p">{</span>
</span><span class='line'>  <span class="o">%</span><span class="n">orig</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">UIAlertView</span> <span class="o">*</span><span class="n">alert</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIAlertView</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithTitle:</span><span class="s">@&quot;Welcome&quot;</span>
</span><span class='line'>      <span class="nl">message:</span><span class="s">@&quot;Welcome to your iPhone Brandon!&quot;</span>
</span><span class='line'>      <span class="nl">delegate:</span><span class="nb">nil</span>
</span><span class='line'>      <span class="nl">cancelButtonTitle:</span><span class="s">@&quot;Thanks&quot;</span>
</span><span class='line'>      <span class="nl">otherButtonTitles:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'>  <span class="p">[</span><span class="n">alert</span> <span class="n">show</span><span class="p">];</span>
</span><span class='line'>  <span class="p">[</span><span class="n">alert</span> <span class="n">release</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="o">%</span><span class="n">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>因为我们要用到hook（钩子）钩取系统开机时候调用的其中一个函数，在那个函数中插入我们的Alert。%orig;功能是执行这个函数原来的动作。如果你想完完全全禁止某个函数的功能，不使用 %orig;即可。</p>

<p>然后打开Makefile文件添加</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">HelloWorld_FRAMEWORKS</span> <span class="o">=</span> UIKit
</span></code></pre></td></tr></table></div></figure>


<hr />

<h3>5.编译和安装</h3>

<p>至此，便到了编译和安装的步骤：</p>

<p><strong>1.利用ssh安装</strong></p>

<p>首先export iPhone的ip：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span><span class="nb">export </span><span class="nv">THEOS_DEVICE_IP</span><span class="o">=</span>192.168.1.115
</span></code></pre></td></tr></table></div></figure>


<p>然后输入：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>make install
</span></code></pre></td></tr></table></div></figure>


<p>在运行过程中可能会多次要求输入密码，默认是alpine。安装完成后，你的设备就会自动重启，并且会显示你自定义的信息。</p>

<p><strong>2.自行打包手动安装</strong></p>

<p>打开控制台，进入到你的这个工程文件夹，使用命令</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>make
</span><span class='line'>make package
</span></code></pre></td></tr></table></div></figure>


<p>然后会生成一个com.yourcompany.fooproject_0.0.1-1_iphoneos-arm.deb这样的包在你的目录中，</p>

<p>然后利用iFunbox，iTools等工具将改包放到/private/var/root/Media/Cydia/AutoInstall/中，那么就会自动安装。</p>

<p>或者也可以使用iFiles手动安装。</p>

<hr />

<h3>PS：</h3>

<p>在输入make install后可能会出现一下几种情况：</p>

<h5>1.ssh Connection refused</h5>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>ssh: connect to host 192.168.1.115 port 22: Connection refused
</span><span class='line'>lost connection
</span></code></pre></td></tr></table></div></figure>


<p>这是因为你还没有打开ssh，在SBSettings里的开关中你应该见到对应的开关。</p>

<h5>2.Connection closed by remote host</h5>

<p>从Cydia里安装SBSettings和OpenSSH后，如果在终端里输入</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>ssh root@192.168.1.115           // iPhone和Mac处于同一网络下
</span></code></pre></td></tr></table></div></figure>


<p>后，出现</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>ssh_exchange_identification: Connection closed by remote host
</span></code></pre></td></tr></table></div></figure>


<p>那么应该立刻使用iFunBox等软件进入iPhone的文件系统，并删除以下内容</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>/System/Library/LaunchDaemons/com.ikey.bbot.plist
</span><span class='line'>/bin/poc-bbot
</span></code></pre></td></tr></table></div></figure>


<p>然后重新安装OpenSSH。</p>

<p>出现以上问题，说明你的iPhone已经中了名叫ikee的病毒，所以如果装了OpenSSH后，应该立刻改掉你的root密码，默认是alpine。例如在Cydia安装Mobile Terminal，然后输入</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>su
</span><span class='line'>// 输入密码如：alpine
</span><span class='line'><span class="nv">$ </span>passwd root // 输入新密码
</span></code></pre></td></tr></table></div></figure>


<p>参考资料：<a href="http://hi.baidu.com/celavi/item/83c5c68e241b5cd55f0ec1ad">[iPhone]OpenSSH连不上：ssh_exchange_identification: Connection closed by remote host</a></p>

<h5>3.collect2: ld terminated with signal 6 [Abort trap: 6]</h5>

<p>出现如下错误：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>Making all <span class="k">for </span>tweak PreferenceLoader...
</span><span class='line'>Preprocessing Tweak.xm...
</span><span class='line'>Compiling Tweak.xm...
</span><span class='line'>Linking tweak PreferenceLoader...
</span><span class='line'>collect2: ld terminated with signal 6 <span class="o">[</span>Abort <span class="nb">trap</span>: 6<span class="o">]</span>
</span><span class='line'>ld<span class="o">(</span>8724,0x7fff78fd2960<span class="o">)</span> malloc: *** error <span class="k">for </span>object 0x7f89b35003f0: pointer being freed was not allocated
</span><span class='line'>*** <span class="nb">set </span>a breakpoint in mallocerror_break to debug
</span><span class='line'>make<span class="o">[</span>2<span class="o">]</span>: *** <span class="o">[</span>obj/PreferenceLoader.dylib<span class="o">]</span> Error 1
</span><span class='line'>make<span class="o">[</span>1<span class="o">]</span>: *** <span class="o">[</span>internal-library-all<span class="o">]</span> Error 2
</span><span class='line'>make: *** <span class="o">[</span>PreferenceLoader.all.tweak.variables<span class="o">]</span> Error 2
</span></code></pre></td></tr></table></div></figure>


<p>那是因为Xcode4.5附带的两个不同版本的链接器。一个用于gcc来编译armv6架构，另一个clang则不会产生armv6的输出。现在没有理由用6.0的SDK去targetiOS4.3以下的系统，或其它基于armv6的平台。我们可以在Makefile最顶部加上如下两句：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">export </span><span class="nv">ARCHS</span><span class="o">=</span>armv7
</span><span class='line'><span class="nb">export </span><span class="nv">TARGET</span><span class="o">=</span>iphone:latest:4.3
</span></code></pre></td></tr></table></div></figure>


<p>另外，如果要兼容低版本那么可以替换为：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">export </span><span class="nv">ARCHS</span><span class="o">=</span>armv6 armv7
</span><span class='line'><span class="nb">export </span><span class="nv">TARGET</span><span class="o">=</span>iphone:&lt;sdkversion-lower-than-6.0&gt;:&lt;deployment target-higher-than-3.0&gt;
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[安装和配置Octopress]]></title>
    <link href="http://gbammc.github.io/blog/2013/10/02/an-zhuang-he-pei-zhi-octopress/"/>
    <updated>2013-10-02T21:26:00+08:00</updated>
    <id>http://gbammc.github.io/blog/2013/10/02/an-zhuang-he-pei-zhi-octopress</id>
    <content type="html"><![CDATA[<h2>前言：</h2>

<p>在平时的学习中，深深受益于网络上很多乐意分享自己学习成果的大牛，因此也想找一个途径来记录并分享自己的学习情况，并希望藉此能促进自己的练级速度和深度，所以最终也决定以写blog的形式来做这件事。</p>

<p>最近程序猿界流行用Octopress + Github Pages的方式来搭建自己的个人blog，所以也就跟风学习一下。（主要是觉得Octopress是开源的，自由度很高，不像某度，某sdn等，会强插各种没用的广告或效果。<strong>Less is more.</strong> 越纯粹，越好。）</p>

<!-- more -->


<hr />

<h2>安装：</h2>

<p>不知道什么原因，跟着<a href="http://octopress.org/">Octopress</a>官网的教程一步步做，在输入<code>rake deploy</code>后会出现以下问题：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c">## Pushing generated _deploy website</span>
</span><span class='line'>To git@github.com:gbammc/gbammc.github.io.git
</span><span class='line'> ! <span class="o">[</span>rejected<span class="o">]</span>        master -&gt; master <span class="o">(</span>non-fast-forward<span class="o">)</span>
</span><span class='line'>error: failed to push some refs to <span class="s1">&#39;git@github.com:gbammc/gbammc.github.io.git&#39;</span>
</span><span class='line'>hint: Updates were rejected because the tip of your current branch is behind
</span><span class='line'>hint: its remote counterpart. Merge the remote changes <span class="o">(</span>e.g. <span class="s1">&#39;git pull&#39;</span><span class="o">)</span>
</span><span class='line'>hint: before pushing again.
</span><span class='line'>hint: See the <span class="s1">&#39;Note about fast-forwards&#39;</span> in <span class="s1">&#39;git push --help&#39;</span> <span class="k">for </span>details.
</span></code></pre></td></tr></table></div></figure>


<p>又经过多次搜索大牛的文章以后，终于在按照<a href="http://evsseny.appspot.com/2012/03/30/Octopress-blog-install.html">这里</a>的步骤以后安装完成。为免日后找不到，就在这里再列一下吧。</p>

<h3>安装rvm和ruby</h3>

<p>首先安装rvm：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>bash -s stable &lt; &lt;<span class="o">(</span>curl -s https://raw.github.com/wayneeseguin/rvm/master/binscripts/rvm-installer<span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>然后设置classpath ( shell 下 )：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">echo</span> <span class="err">&#39;</span><span class="o">[[</span> -s <span class="s2">&quot;$HOME/.rvm/scripts/rvm&quot;</span> <span class="o">]]</span> <span class="o">&amp;&amp;</span> . <span class="s2">&quot;$HOME/.rvm/scripts/rvm&quot;</span>
</span><span class='line'><span class="nb">source</span> ~/.bash_profile
</span></code></pre></td></tr></table></div></figure>


<p>最后安装ruby：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>rvm install 1.9.3 <span class="o">&amp;&amp;</span> rvm use 1.9.3
</span><span class='line'>rvm rubygems latest
</span></code></pre></td></tr></table></div></figure>


<p>最新版的Octopress只支持ruby 1.9.3版本以上，所以已经安装旧版ruby的同学还需升级一下。</p>

<h3>安装Octopress</h3>

<p>先从github上将源码clone下来：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>git clone git://github.com/imathis/octopress.git octopress    <span class="c"># 从github clone octopress的源代码，后面的octopress是本地存放文件夹的名称，可以自定</span>
</span><span class='line'><span class="nb">cd </span>octopress      <span class="c"># 进入所选的文件夹</span>
</span><span class='line'>ruby --version    <span class="c"># 应该显示Ruby 1.9.3</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后安装一些依赖：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>gem install bundler
</span><span class='line'>bundle install
</span><span class='line'>rake install    <span class="c"># 安装主题</span>
</span><span class='line'>rake preview    <span class="c"># 本地预览 （http://localhost:4000/）</span>
</span></code></pre></td></tr></table></div></figure>


<h3>把blog部署到github：</h3>

<p>创建一个名称为user_name.github.com的repo（必须使用username.github.com这种格式命名仓库，页面生成需要几分钟的时间才可以正常访问<code>http://user_name.github.com</code>或者<code>http://user_name.github.io</code>）</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>rake setup_github_pages <span class="c"># 和github创建关联</span>
</span><span class='line'>git@github.com:your_username/your_username.github.com.git   <span class="c"># 按提示输入github URL</span>
</span><span class='line'>rake generate <span class="c"># 把你所有编辑的内容生成你的Blog静态页面</span>
</span><span class='line'>rake deploy   <span class="c"># &lt;span class=&quot;goog_qs-tidbit goog_qs-tidbit-0&quot;&gt;如果检查没有任何问题就可以 push 你的 blog 到 github master branch&lt;/span&gt; </span>
</span><span class='line'>＃ 状态检查
</span><span class='line'><span class="nb">cd</span> ~/octopress
</span><span class='line'>git status   <span class="c"># 应该显示 On branch source</span>
</span><span class='line'><span class="nb">cd </span>_deploy/  <span class="c"># 应该显示 On branch master</span>
</span><span class='line'>＃ 最后提交到source branch
</span><span class='line'>git add .
</span><span class='line'>git commit -m <span class="s1">&#39;first commit&#39;</span>
</span><span class='line'>git push origin <span class="nb">source</span> <span class="c"># 如果这一步出错，请再次检查仓库名称是否按要求命名，同时检查Admin面板下Default Branch是否为 master</span>
</span></code></pre></td></tr></table></div></figure>


<p>但是到这里，当我去看Admin面板时，却只有source这个分支，而没有master分支，只有当我提交一篇文章后，master分支才出现。可能是因为Octopress的源文件都存放于source分支下，而deploy的都在master分支上。<a href="http://huanggang.me/archives/654">这里</a>有相关解释</p>

<pre><code>还有很重要的一步是把你的修改(文本修改，不包含”_deploy”目录，”deploy”目录保存;
”rake generate”生成的静态页面内容，会被”rake deploy”命令提交到”master branch”)
放到你的github pages(“source” branch)上
</code></pre>

<h3>更新Octopress</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>git pull octopress master     <span class="c"># Get the latest Octopress</span>
</span><span class='line'>bundle install                <span class="c"># Keep gems updated</span>
</span><span class='line'>rake update_source            <span class="c"># update the template&#39;s source</span>
</span><span class='line'>rake update_style             <span class="c"># update the template&#39;s style</span>
</span></code></pre></td></tr></table></div></figure>


<h3>写博客方法</h3>

<p>写博客主要是用以下几个命令，<a href="http://octopress.org/docs/blogging/">这里</a>有详细介绍：</p>

<ul>
<li>rake new_post[‘article name’] 生成博文框架，然后修改在source/_posts/下生成的文件即可</li>
<li>rake generate 生成静态文件</li>
<li>rake watch 检测文件变化，实时生成新内容</li>
<li>rake preview 在本机4000端口生成访问内容</li>
<li>rake deploy 发布文件</li>
</ul>


<p>博文是采用markdown语法，另外增加了一些扩充的插件，markdown的介绍文章网上可以搜到很多，比如<a href="http://daringfireball.net/projects/markdown/">这个</a>。</p>

<h4>zsh下无法新建博客的原因</h4>

<p>在 zsh 中若出现‘*’, ‘(’, ‘|’, ‘&lt;’, ‘[’, or ‘?’符号，则将其识别为查找文件名的通配符</p>

<p>快速解决：用引号括起来$ rake &ldquo;new_post[new_post.markdown]&rdquo;</p>

<p>彻底解决：取消zsh的通配(GLOB), 在.zshrc中加入alias rake=&ldquo;noglob rake&rdquo;</p>

<hr />

<h2>我的配置</h2>

<h3>分享和评论</h3>

<p>因为GFW的原因，我们需要先删除一些东西，不然会造成加载很慢的情况。</p>

<ul>
<li>/_config.yml，把里面的twitter相关信息全部删掉</li>
<li>/source/_includes/custom/head.html 把google的自定义字体去掉，原因同上。</li>
</ul>


<p>在/_config.yml 这个配置文件里的每一项都有相应的注释，可以改一些博客头，作者名之类的东西。</p>

<p>而配置评论和分享到微博功能。步骤如下：</p>

<ul>
<li>在_config.yml中增加一项： weibo_share: true</li>
<li>修改 source/_includes/post/sharing.html ，增加：</li>
</ul>


<br/>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>// 下面的大括号是全角的，如果复制，请自行改成半角
</span><span class='line'>｛% <span class="k">if </span>site.weibo_share %｝
</span><span class='line'>｛% include post/weibo.html %｝
</span><span class='line'>｛% endif %｝
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>增加文件：source/_includes/post/weibo.html</li>
<li>访问 <a href="http://www.jiathis.com/">http://www.jiathis.com/</a> ，获取分享的代码</li>
<li>访问 <a href="http://uyan.cc/">http://uyan.cc/</a> ，获得评论的代码</li>
<li>将上面2步的代码都加入到weibo.html中即可</li>
</ul>


<h3>主题</h3>

<p>如果需要使用像我这样的主题，那么请参考这个：<a href="http://shashankmehta.in/archive/2012/greyshade.html">Introducing an Octopress Theme, Greyshade!</a></p>

<p>还需要带微博或Dribble分享的话，请参考这个：<a href="http://www.imallen.com/blog/2013/05/12/add-support-for-weibo-and-dribbble-to-greyshade.html">为 Octopress 的 Greyshade 主题增加新浪微博和 Dribbble 的支持</a></p>

<h3>更多参考博文(注：侧栏设置并不适用于Greyshade主题)：</h3>

<p><a href="http://shanewfx.github.io/blog/2012/08/13/improve-blog-theme/">Octopress主题改造</a></p>

<p><a href="http://www.yanjiuyanjiu.com/blog/20130402/">我的Octopress配置</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hello world]]></title>
    <link href="http://gbammc.github.io/blog/2013/10/01/hello-world/"/>
    <updated>2013-10-01T11:40:00+08:00</updated>
    <id>http://gbammc.github.io/blog/2013/10/01/hello-world</id>
    <content type="html"><![CDATA[<p>折腾了两个晚上，终于搞好Octopress啦~</p>

<p>按照编程习惯，第一篇文章献给&#8221;Hello World！&#8221;。</p>

<p>决定写Blog，一方面是想对所学知识进行梳理，另一方面是想自己写的东西也能对别人有些帮助，正所谓&#8221;予人玫瑰，手留余香&#8221;，这同时是一个相互学习的机会。</p>

<p>而以后要做的，就是坚持写Blog的习惯！</p>
]]></content>
  </entry>
  
</feed>
